from __future__ import unicode_literals
#ANNOTATION: from __future__ import unicode_literals into default name space.

import fnmatch
#ANNOTATION: import module fnmatch.
import glob
#ANNOTATION: import module glob.
import io
#ANNOTATION: import module io.
import os
#ANNOTATION: import module os.
import re
#ANNOTATION: import module re.
import sys
#ANNOTATION: import module sys.
from itertools import dropwhile
#ANNOTATION: from itertools import dropwhile into default name space.

import django
#ANNOTATION: import module django.
from django.core.management.base import CommandError, BaseCommand
#ANNOTATION: from django.core.management.base import CommandError and BaseCommand into default name space.
from django.core.management.utils import (handle_extensions, find_command,
    popen_wrapper)
#ANNOTATION: from django.core.management.utils import handle_extensions, find_command and popen_wrapper into default name space.
from django.utils.encoding import force_str
#ANNOTATION: from django.utils.encoding import force_st into default name space.
from django.utils.functional import total_ordering
#ANNOTATION: from django.utils.functional import total_ordering into default name space.
from django.utils import six
#ANNOTATION: from django.utils import six into default name space.
from django.utils.text import get_text_list
#ANNOTATION: from django.utils.text import get_text_list into default name space.
from django.utils.jslex import prepare_js_for_gettext
#ANNOTATION: from django.utils.jslex import prepare_js_for_gettext into default name space.

plural_forms_re = re.compile(r'^(?P<value>"Plural-Forms.+?\\n")\s*$', re.MULTILINE | re.DOTALL)
#ANNOTATION: call the method re.compile with 2 arguments: raw string '^(?P<value>"Plural-Forms.+?\\n")\s*$',
#ANNOTATION: and result of the bitwise OR performed on the re.MULTILINE and re.DOTALL operands, substitute the result for plural_forms_re/
STATUS_OK = 0
#ANNOTATION: STATUS_OK is integer 0.


def check_programs(*programs):
#ANNOTATION: define the method check_programs with an argument unpacked list programs.
    for program in programs:
#ANNOTATION: for every program in programs,
        if find_command(program) is None:
#ANNOTATION: call the function find_command with an argument program, if it evaluates to None,
            raise CommandError("Can't find %s. Make sure you have GNU "
                    "gettext tools 0.15 or newer installed." % program)
#ANNOTATION: raise an CommandError exception with an argument "Can't find %s. Make sure you have GNU gettext tools 0.15 or newer installed.", #ANNOTATION: where '%s' is replaced with program.


@total_ordering
#ANNOTATION: total_ordering decorator,
class TranslatableFile(object):
#ANNOTATION: derive the class TranslatableFile from the object class.
    def __init__(self, dirpath, file_name, locale_dir):
#ANNOTATION: define the method __init__ with 4 arguments: self, dirpath, file_name and locale_dir. 
        self.file = file_name
#ANNOTATION: substitute file_name for self.file_name.
        self.dirpath = dirpath
#ANNOTATION: substitute dirpath for self.dirpath.
        self.locale_dir = locale_dir
#ANNOTATION: substitute locale_dir for self.locale_dir.

    def __repr__(self):
#ANNOTATION: define the method __repr__with an argument self.
        return "<TranslatableFile: %s>" % os.sep.join([self.dirpath, self.file])
#ANNOTATION: join self.dirpath and self.file in a string, substitute with it '%s' in string "<TranslatableFile: %s>", return the result.

    def __eq__(self, other):
#ANNOTATION: define the method __eq__ with self and other arguments:
        return self.path == other.path
#ANNOTATION: if self.path equals other.path, return boolean True, if not return boolean False.

    def __lt__(self, other):
#ANNOTATION: define the mehod __lt__ with self and other.
        return self.path < other.path
#ANNOTATION: if self.path is lesser than other.path, return boolean True, otherwise return boolean False.

    @property
#ANNOTATION: property decorator.
    def path(self):
#ANNOTATION: define the method path with an argument self.
        return os.path.join(self.dirpath, self.file)
#ANNOTATION: join self.dirpath and self.file into a file path, return it.

    def process(self, command, domain):
#ANNOTATION: define the method process with 3 arguments: self, command and domain.
        """
        Extract translatable literals from self.file for :param domain:,
        creating or updating the POT file.

        Uses the xgettext GNU gettext utility.
        """
#ANNOTATION: docstring

        from django.conf import settings
#ANNOTATION: from django.conf import settings into default namespace.
        from django.utils.translation import templatize
#ANNOTATION: from django.utils.translation import templatize into default namespace.

        if command.verbosity > 1:
#ANNOTATION: if command.verbosity is greater than integer 1,
            command.stdout.write('processing file %s in %s\n' % (self.file, self.dirpath))
#ANNOTATION: substitute '%s' is string 'processing file %s in %s\n' with self.file and self.dirpath, write it to command.stdout.
        _, file_ext = os.path.splitext(self.file)
#ANNOTATION: call the method os.path.splitext with an argument self.file, assign the result to _ and file_ext. 
        if domain == 'djangojs' and file_ext in command.extensions:
#ANNOTATION: if domain equals a string 'djangojs' and file_ext is contained in command.extensions,
            is_templatized = True
#ANNOTATION: is_templatized is boolean True.
            orig_file = os.path.join(self.dirpath, self.file)
#ANNOTATION: join self.dirpath and self.file into a file path, substitute it for orig_file.
            with io.open(orig_file, encoding=settings.FILE_CHARSET) as fp:
#ANNOTATION: call the function io.open with orig_file and encoding set to settings.FILE_CHARSET, with the result renamed to fp, 
#ANNOTATION: perform the following:
                src_data = fp.read()
#ANNOTATION: call the method fp.read, substitute the result for src_data. 
            src_data = prepare_js_for_gettext(src_data)
#ANNOTATION: call the function prepare_js_for_gettext with an argument src_data, substitute it for src_data.
            thefile = '%s.c' % self.file
#ANNOTATION: convert self.file to a string and append '.c' string to it, substitute the result for thefile.
            work_file = os.path.join(self.dirpath, thefile)
#ANNOTATION: join self.dirpath and thefile in a string, substitute the result for work_file.
            with io.open(work_file, "w", encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: work_file, string 'w' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
                fp.write(src_data)
#ANNOTATION: call the method fp.write with an arguments src_data.
            args = [
                'xgettext',
                '-d', domain,
                '--language=C',
                '--keyword=gettext_noop',
                '--keyword=gettext_lazy',
                '--keyword=ngettext_lazy:1,2',
                '--keyword=pgettext:1c,2',
                '--keyword=npgettext:1c,2,3',
                '--output=-'
            ] + command.xgettext_options
#ANNOTATION: append command.xgettext_options to the list containing 10 elements: string 'xgettext', string '-d', domain, string '--language=C',
#ANNOTATION: string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2',
#ANNOTATION: string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3' and string '--output=-', substitute it for args.
            args.append(work_file)
#ANNOTATION: append work_file to args.
        elif domain == 'django' and (file_ext == '.py' or file_ext in command.extensions):
#ANNOTATION: otherwise if domains equals a string django' and, file_ext equals '.py' or file_ext is contained in command.extensions,
            thefile = self.file
#ANNOTATION: substitute self.file for thefile.
            orig_file = os.path.join(self.dirpath, self.file)
#ANNOTATION: join self.dirpath and self.file into a file path, substitute it for orig_file.
            is_templatized = file_ext in command.extensions
#ANNOTATION: if file_ext is contained in command.extensions, is_templatized is boolean True, otherwise it is boolean False.
            if is_templatized:
#ANNOTATION: if is_templatized is true,
                with io.open(orig_file, 'r', encoding=settings.FILE_CHARSET) as fp:
#ANNOTATION: call the function io.open with 3 arguments: work_file, string 'w' and encoding set to settings.FILE_CHARSET as arguments,
#ANNOTATION: with the result renamed to fp, perform the following:
                    src_data = fp.read()
#ANNOTATION: call the method fp.read, substitute the result for src_data.
                thefile = '%s.py' % self.file
#ANNOTATION: convert self.file to string and append string '.py' to it, substitute the result for thefile.
                content = templatize(src_data, orig_file[2:])
#ANNOTATION: call the function templatize with 2 arguments: src_data and sliced orig_file, without first 2 elements, substitute the result for content.
                with io.open(os.path.join(self.dirpath, thefile), "w", encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: self.dirpath and thefile joined into a file path, string 'w',
#ANNOTATION: and encoding set to string 'utf-8' as arguments, with the result renamed to fp, perform the following:
                    fp.write(content)
#ANNOTATION: call the method fp.write with an argument content.
            work_file = os.path.join(self.dirpath, thefile)
#ANNOTATION: join self.dirpath, thefile into a file path, substitute it for work_file.
            args = [
                'xgettext',
                '-d', domain,
                '--language=Python',
                '--keyword=gettext_noop',
                '--keyword=gettext_lazy',
                '--keyword=ngettext_lazy:1,2',
                '--keyword=ugettext_noop',
                '--keyword=ugettext_lazy',
                '--keyword=ungettext_lazy:1,2',
                '--keyword=pgettext:1c,2',
                '--keyword=npgettext:1c,2,3',
                '--keyword=pgettext_lazy:1c,2',
                '--keyword=npgettext_lazy:1c,2,3',
                '--output=-'
            ] + command.xgettext_options
#ANNOTATION: append command.xgettext_options to list containing 15 elements: string 'xgettext', string '-d', domain, string '--language=Python',
#ANNOTATION: string '--keyword=gettext_noop', string '--keyword=gettext_lazy', string '--keyword=ngettext_lazy:1,2',
#ANNOTATION: string '--keyword=ugettext_noop', string '--keyword=ugettext_lazy', string '--keyword=ungettext_lazy:1,2',
#ANNOTATION: string '--keyword=pgettext:1c,2', string '--keyword=npgettext:1c,2,3', string '--keyword=pgettext_lazy:1c,2',
#ANNOTATION: string '--keyword=npgettext_lazy:1c,2,3' and string '--output=-', substitute the result for args.
            args.append(work_file)
#ANNOTATION: append work_file to args.
        else:
#ANNOTATION: if not, 
            return
#ANNOTATION: return nothing.
        msgs, errors, status = popen_wrapper(args)
#ANNOTATION: call the function popen_wrapper with argument args, assign the result to msgs, errors and status.
        if errors:
#ANNOTATION: if errors is true,
            if status != STATUS_OK:
#ANNOTATION: if status is not equal to STATUS_OK,
                if is_templatized:
#ANNOTATION: if is_templatized is true,
                    os.unlink(work_file)
#ANNOTATION: call the function os.unlink with an argument work_file.
                raise CommandError(
                    "errors happened while running xgettext on %s\n%s" %
                    (self.file, errors))
#ANNOTATION: raise an CommandError exception with an argument string "errors happened while running xgettext on %s\n%s", 
#ANNOTATION: where '%s' are replaced by sel.file and errors, respectively.
            elif command.verbosity > 0:
#ANNOTATION: if command.verbosity is greater than integer 0,
                # Print warnings
                command.stdout.write(errors)
#ANNOTATION: call the method command.stdout.write with an argument errors.
        if msgs:
#ANNOTATION: if msgs is true,
            if six.PY2:
#ANNOTATION: if six.PY2 is true,
                msgs = msgs.decode('utf-8')
#ANNOTATION: call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.
            # Write/append messages to pot file
            potfile = os.path.join(self.locale_dir, '%s.pot' % str(domain))
#ANNOTATION: join into a file path: self.locale_dir and string '.pot' appended to domain converted to string, substitute it for potfile.
            if is_templatized:
#ANNOTATION: if is_templatized is true,
                # Remove '.py' suffix
                if os.name == 'nt':
#ANNOTATION: if os.name equals string 'nt',
                    # Preserve '.\' prefix on Windows to respect gettext behavior
                    old = '#: ' + work_file
#ANNOTATION: append work_file to string '#: ', substitute it for old.
                    new = '#: ' + orig_file
#ANNOTATION: append orig_file to string '#: ', substitute it for new.
                else:
#ANNOTATION: if not,
                    old = '#: ' + work_file[2:]
#ANNOTATION: append work_file to string '#: ', substitute it for old.
                    new = '#: ' + orig_file[2:]
#ANNOTATION: append orig_file to string '#: ', substitute it for new.
                msgs = msgs.replace(old, new)
#ANNOTATION: replace every occurrence of old for new in msgs, substitute the result for msgs.
            write_pot_file(potfile, msgs)
#ANNOTATION: call the function write_pot_file with 2 arguments: potfile and msgs.

        if is_templatized:
#ANNOTATION: if is_templatized is true,
            os.unlink(work_file)
#ANNOTATION: call the function os.unlink with an argument work_file.


def write_pot_file(potfile, msgs):
#ANNOTATION: define the function write_pot_file with 2 arguments potfile and msgs.
    """
    Write the :param potfile: POT file with the :param msgs: contents,
    previously making sure its format is valid.
    """
#ANNOTATION: docstring
    if os.path.exists(potfile):
#ANNOTATION: if potfile fie exists,
        # Strip the header
        msgs = '\n'.join(dropwhile(len, msgs.split('\n')))
#ANNOTATION: call the function dropwhile with 2 arguments: function len and msgs spit into parts at newlines, join the result into a string,
#ANNOTATION: separated by newline, substitute it for msgs. 
    else:
#ANNOTATION: if not,
        msgs = msgs.replace('charset=CHARSET', 'charset=UTF-8')
#ANNOTATION: replace every occurrence of string 'charset=CHARSET' for string  'charset=UTF-8' in msgs, substitute the result for msgs.
    with io.open(potfile, 'a', encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: potfile, string 'a' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
        fp.write(msgs)
#ANNOTATION: call the method fp.write with an argument msgs.


class Command(BaseCommand):
#ANNOTATION: derive the class Command from the BaseCommands base class.
    help = ("Runs over the entire source tree of the current directory and "
"pulls out all strings marked for translation. It creates (or updates) a message "
"file in the conf/locale (in the django tree) or locale (for projects and "
"applications) directory.\n\nYou must run this command with one of either the "
"--locale, --exclude or --all options.")
#ANNOTATION: help is a string "Runs over the entire source tree of the current directory and "
#ANNOTATION: "pulls out all strings marked for translation. It creates (or updates) a message "
#ANNOTATION: "file in the conf/locale (in the django tree) or locale (for projects and "
#ANNOTATION: "applications) directory.\n\nYou must run this command with one of either the "
#ANNOTATION: "--locale, --exclude or --all options.".

    requires_system_checks = False
#ANNOTATION:  requires_system_checks is boolean False.
    leave_locale_alone = True
#ANNOTATION: leave_locale_alone is boolean True

    msgmerge_options = ['-q', '--previous']
#ANNOTATION: msgmerge_options is an list with elements: strings '-q' and '--previous'.
    msguniq_options = ['--to-code=utf-8']
#ANNOTATION: msguniq_options is an list with elements: string '--to-code=utf-8'.
    msgattrib_options = ['--no-obsolete']
#ANNOTATION: msgattrib_options is an list with elements: string '--no-obsolete'.
    xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators']
#ANNOTATION: xgettext_options is an list with elements: strings '--from-code=UTF-8' and '--add-comments=Translators'.

    def add_arguments(self, parser):
#ANNOTATION: define the method add_arguments with 2 arguments: self and parser.
        parser.add_argument('--locale', '-l', default=[], dest='locale', action='append',
            help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '
                 'Can be used multiple times.')
#ANNOTATION: call the method parser.add_argument with 6 arguments: string '--locale', string '-l', default as an empty list, 
#ANNOTATION: dest as a string 'locale', action as a string 'append' and help as a string,
#ANNOTATION: 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). Can be used multiple times.'.
        parser.add_argument('--exclude', '-x', default=[], dest='exclude', action='append',
                    help='Locales to exclude. Default is none. Can be used multiple times.')
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--exclude', string '-x', default as a empty list, 
#ANNOTATION: dest as a string 'exclude', action as a string 'append' and help as a string 'Locales to exclude. Default is none. Can be used multiple times.'.
        parser.add_argument('--domain', '-d', default='django', dest='domain',
            help='The domain of the message files (default: "django").')
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--domain', string '-d', default as a string 'django', 
#ANNOTATION: dest set to string 'domain' and help as a string 'The domain of the message files (default: "django").'.
        parser.add_argument('--all', '-a', action='store_true', dest='all',
            default=False, help='Updates the message files for all existing locales.')
#ANNOTATION: call the method parser.add_argument with 6 arguments: string '--all', string '-a', action as a string'store_true', 
#ANNOTATION: dest as a string 'all' default as boolean False and help as a string 'Updates the message files for all existing locales.'.
        parser.add_argument('--extension', '-e', dest='extensions',
            help='The file extension(s) to examine (default: "html,txt", or "js" '
                 'if the domain is "djangojs"). Separate multiple extensions with '
                 'commas, or use -e multiple times.',
            action='append')
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--extension', string '-e', dest set to string 'extensions',
#ANNOTATION: help set to a string 'The file extension(s) to examine (default: "html,txt", or "js" '
#ANNOTATION: 'if the domain is "djangojs"). Separate multiple extensions with commas, or use -e multiple times.' and action as a string 'append'.
        parser.add_argument('--symlinks', '-s', action='store_true', dest='symlinks',
            default=False, help='Follows symlinks to directories when examining '
                                'source code and templates for translation strings.')
#ANNOTATION: call the method parser.add_argument with 6 arguments: string '--symlinks', string '-s', action as a string 'store_true',
#ANNOTATION: dest as a string 'symlinks', default as boolean False and help as a string 'Follows symlinks to directories when examining '
#ANNOTATION: 'source code and templates for translation strings.'.
        parser.add_argument('--ignore', '-i', action='append', dest='ignore_patterns',
            default=[], metavar='PATTERN',
            help='Ignore files or directories matching this glob-style pattern. '
                 'Use multiple times to ignore more.')
#ANNOTATION: call the method parser.add_argument with 7 arguments: string '--ignore', string '-i', action as a string 'append',
#ANNOTATION: dest as a string 'ignore_patterns', default as an empty list, metavar as a string 'PATTERN',
#ANNOTATION: and help as a string 'Ignore files or directories matching this glob-style pattern. Use multiple times to ignore more.'.
        parser.add_argument('--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',
            default=True, help="Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.")
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--no-default-ignore', action as a string 'store_false',
#ANNOTATION: dest as a string 'use_default_ignore_patterns', default set to boolean True,
#ANNOTATION: and help as a string "Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.".
        parser.add_argument('--no-wrap', action='store_true', dest='no_wrap',
            default=False, help="Don't break long message lines into several lines.")
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--no-wrap', action as a string 'store_true', dest as a string 'no_wrap',
#ANNOTATION: default as boolean False and help as a string "Don't break long message lines into several lines.".
        parser.add_argument('--no-location', action='store_true', dest='no_location',
            default=False, help="Don't write '#: filename:line' lines.")
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--no-location', action set to string 'store_true', 
#ANNOTATION: dest set to string 'no_location', default as boolean False and help as a string "Don't write '#: filename:line' lines.".
        parser.add_argument('--no-obsolete', action='store_true', dest='no_obsolete',
            default=False, help="Remove obsolete message strings.")
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--no-obsolete', action as a string 'store_true', 
#ANNOTATION: dest as a string 'no_obsolete', default as boolean False and help as a string "Remove obsolete message strings.".
        parser.add_argument('--keep-pot', action='store_true', dest='keep_pot',
            default=False, help="Keep .pot file after making messages. Useful when debugging.")
#ANNOTATION: call the method parser.add_argument with 5 arguments: string '--keep-pot', action as a string 'store_true', 
#ANNOTATION: dest as a string 'keep_pot', default as boolean False and help as a string "Keep .pot file after making messages. Useful when debugging."

    def handle(self, *args, **options):
#ANNOTATION: define the method handle with 3 arguments: self, unpacked list args and unpacked dictionary options.
        locale = options.get('locale')
#ANNOTATION: get the value under the 'locale' key of the options dictionary, substitute it for locale.
        exclude = options.get('exclude')
#ANNOTATION: get the value under the 'exclude' key of the options dictionary, substitute it for exclude.
        self.domain = options.get('domain')
#ANNOTATION: get the value under the 'domain' key of the options dictionary, substitute it for self.domain.
        self.verbosity = options.get('verbosity')
#ANNOTATION: get the value under the 'verbosity' key of the options dictionary, substitute it for self.verbosity.
        process_all = options.get('all')
#ANNOTATION: get the value under the 'all' key of the options dictionary, substitute it for process_all.
        extensions = options.get('extensions')
#ANNOTATION: get the value under the 'extensions' key of the options dictionary, substitute it for extensions.
        self.symlinks = options.get('symlinks')
#ANNOTATION: get the value under the 'symlinks' key of the options dictionary, substitute it for self.symlinks.
        ignore_patterns = options.get('ignore_patterns')
#ANNOTATION: get the value under the 'ignore_patterns' key of the options dictionary, substitute it for ignore_patterns.
        if options.get('use_default_ignore_patterns'):
#ANNOTATION: get the value under the 'use_default_ignore_patterns' key of the options dictionary, if it is true,
            ignore_patterns += ['CVS', '.*', '*~', '*.pyc']
#ANNOTATION: append list containing 4 elements: 'CVS', '.*', '*~' and '*.pyc', to ignore_patterns.
        self.ignore_patterns = list(set(ignore_patterns))
#ANNOTATION: put elements of ignore_patterns into a set, substitute the length of it for self.ignore_patterns.

        # Avoid messing with mutable class variables
        if options.get('no_wrap'):
#ANNOTATION: get the value under the 'no_wrap' key of the options dictionary, if it is true,
            self.msgmerge_options = self.msgmerge_options[:] + ['--no-wrap']
#ANNOTATION: append list containing string '--no-wrap' to self.msgmerge_options 
            self.msguniq_options = self.msguniq_options[:] + ['--no-wrap']
#ANNOTATION: append list containing string '--no-wrap' to self.msguniq_options.
            self.msgattrib_options = self.msgattrib_options[:] + ['--no-wrap']
#ANNOTATION: append list containing string '--no-wrap' to self.msgattrib_options.
            self.xgettext_options = self.xgettext_options[:] + ['--no-wrap']
#ANNOTATION: append list containing string '--no-wrap' to self.xgettext_options.
        if options.get('no_location'):
#ANNOTATION: get the value under the 'no_location' key of the options dictionary, if it is true,
            self.msgmerge_options = self.msgmerge_options[:] + ['--no-location']
#ANNOTATION: append list containing string '--no-location' to self.msgmerge_options.
            self.msguniq_options = self.msguniq_options[:] + ['--no-location']
#ANNOTATION: append list containing string '--no-location' to self.msguniq_options.
            self.msgattrib_options = self.msgattrib_options[:] + ['--no-location']
#ANNOTATION: append list containing string '--no-location' to self.msgattrib_options.
            self.xgettext_options = self.xgettext_options[:] + ['--no-location']
#ANNOTATION: append list containing string '--no-location' to self.xgettext_options.

        self.no_obsolete = options.get('no_obsolete')
#ANNOTATION: get the value under the 'no_obsolete' key of the options dictionary, substitute it for self.no_obsolete.
        self.keep_pot = options.get('keep_pot')
#ANNOTATION: get the value under the 'keep_pot' key of the options dictionary, substitute it for self.keep_pot.

        if self.domain not in ('django', 'djangojs'):
#ANNOTATION: if self.domain is not equal to string 'django' or string 'djangojs',
            raise CommandError("currently makemessages only supports domains "
                               "'django' and 'djangojs'")
#ANNOTATION: raise an CommandError exception with an argument string "currently makemessages only supports domains 'django' and 'djangojs'".
        if self.domain == 'djangojs':
#ANNOTATION: if self.domain equals to string 'djangojs',
            exts = extensions if extensions else ['js']
#ANNOTATION: if extensions is false, substitute it for exts, otherwise exts is a list containing string 'js'.
        else:
#ANNOTATION: if not,
            exts = extensions if extensions else ['html', 'txt']
#ANNOTATION: if extensions is false, substitute it for exts, otherwise exts is a list containing 2 elements: string 'html' and string 'txt'.
        self.extensions = handle_extensions(exts)
#ANNOTATION: call the function handle_extensions exts, substitute self.extensions.

        if (locale is None and not exclude and not process_all) or self.domain is None:
#ANNOTATION: evaluate the boolean expression: locale is None and exclude is false and process_all is false, 
#ANNOTATION: if the result is true or self.domain is not None,
            raise CommandError("Type '%s help %s' for usage information." % (
                os.path.basename(sys.argv[0]), sys.argv[1]))
#ANNOTATION: raise an CommandError exception with an argument string "Type '%s help %s' for usage information.", where '%s' are replaced by:
#ANNOTATION: return value of the function os.path.basename called with first element of sys.argv as an argument, and second element of sys.argv.

        # Need to ensure that the i18n framework is enabled
        from django.conf import settings
#ANNOTATION: from django.conf import settings into default namespace.
        if settings.configured:
#ANNOTATION: if settings.configured,
            settings.USE_I18N = True
#ANNOTATION: settings.USE_I18N is boolean True.
        else:
#ANNOTATION: if not,
            settings.configure(USE_I18N=True)
#ANNOTATION: call the method settings.configure with an argument USE_I18N set to boolean True.

        if self.verbosity > 1:
#ANNOTATION: if self.verbosity is integer 1,
            self.stdout.write('examining files with the extensions: %s\n'
                             % get_text_list(list(self.extensions), 'and'))
#ANNOTATION: call the method self.stdout.write with an argument string 'examining files with the extensions: %s\n', 
#ANNOTATION: substitute '%s' with return value of the function get_text_list called with 2 arguments:self.extensions converted into a list and string 'and'.

        self.invoked_for_django = False
#ANNOTATION: self.invoked_for_django is boolean False.
        self.locale_paths = []
#ANNOTATION:  self.locale_paths is an empty list.
        self.default_locale_path = None
#ANNOTATION: self.default_locale_path is None.
        if os.path.isdir(os.path.join('conf', 'locale')):
#ANNOTATION: join 'conf' and 'locale' into a file path, if it is a directory,
            self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'))]
#ANNOTATION: join 'conf' and 'locale' into a file path, use it as an argument for the call the method os.path.abspath, 
#ANNOTATION: put the results into a list, substitute self.locale_paths for it.
            self.default_locale_path = self.locale_paths[0]
#ANNOTATION: substitute first element of self.locale_paths for self.default_locale_path.
            self.invoked_for_django = True
#ANNOTATION: self.invoked_for_django is boolean True.
        else:
#ANNOTATION: if not,
            self.locale_paths.extend(list(settings.LOCALE_PATHS))
#ANNOTATION: convert settings.LOCALE_PATHS into a list and extend list self.locale_paths with it.
            # Allow to run makemessages inside an app dir
            if os.path.isdir('locale'):
#ANNOTATION: if 'locale' is a directory,
                self.locale_paths.append(os.path.abspath('locale'))
#ANNOTATION: call the function os.path.abspath with an argument 'locale', append the result to self.locale_paths. 
            if self.locale_paths:
#ANNOTATION: if self.locale_paths is true,
                self.default_locale_path = self.locale_paths[0]
#ANNOTATION: substitute first element of self.locale_paths for self.default_locale_path.
                if not os.path.exists(self.default_locale_path):
#ANNOTATION: if self.default_locale_path directory doesnt exists,
                    os.makedirs(self.default_locale_path)
#ANNOTATION: create a directory self.default_locale_path.

        # Build locale list
        locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path))
#ANNOTATION: call the function glob.glob with an argument: string '/*' appended to self.default_locale_path converted into a string,
#ANNOTATION: filter out the results for which function os.path.isdir returns false, substitute the result for locale_dirs.
        all_locales = map(os.path.basename, locale_dirs)
#ANNOTATION: map the locale_dirs elements with mapping function os.path.basename, substitute the result for all_locales.

        # Account for excluded locales
        if process_all:
#ANNOTATION: if process_all is true,
            locales = all_locales
#ANNOTATION: substitute all_locales for locales.
        else:
#ANNOTATION: if not,
            locales = locale or all_locales
#ANNOTATION: if locale is not false or None, substitute it for locales, otherwise substitute all_locales for locales.
            locales = set(locales) - set(exclude)
#ANNOTATION: locales is a difference between the locales and exclude sets.

        if locales:
#ANNOTATION: if locales is true,
            check_programs('msguniq', 'msgmerge', 'msgattrib')
#ANNOTATION: call the function check_programs with 3 arguments: strings 'msguniq', 'msgmerge' and 'msgattrib'.

        check_programs('xgettext')
#ANNOTATION: call the function check_programs with an argument string 'xgettext'.

        try:
#ANNOTATION: try,
            potfiles = self.build_potfiles()
#ANNOTATION: call the method self.build_potfiles, substitute the result for potfiles.

            # Build po files for each selected locale
            for locale in locales:
#ANNOTATION: for every locale in locales,
                if self.verbosity > 0:
#ANNOTATION: if self.verbosity is greater than integer 0,
                    self.stdout.write("processing locale %s\n" % locale)
#ANNOTATION: replace '%s' in string "processing locale %s\n" with locale, write it to self.stdout.
                for potfile in potfiles:
#ANNOTATION: for every potfile in potfiles,
                    self.write_po_file(potfile, locale)
#ANNOTATION: call the method self.write_po_file with 2 arguments: potfile and locale.
        finally:
#ANNOTATION: finally perform,
            if not self.keep_pot:
#ANNOTATION: if self.keep_pot is false,
                self.remove_potfiles()
#ANNOTATION: call the method self.remove_potfiles.

    def build_potfiles(self):
#ANNOTATION: define the method build_potfiles with an argument self.
        """
        Build pot files and apply msguniq to them.
        """
#ANNOTATION: docstring
        file_list = self.find_files(".")
#ANNOTATION: call the method self.find_files with an argument string '.', substitute the result for file_list.
        self.remove_potfiles()
#ANNOTATION: call the method self.remove_potfiles.
        for f in file_list:
#ANNOTATION: for f in file_list,
            try:
#ANNOTATION: try,
                f.process(self, self.domain)
#ANNOTATION: call the function f.process with 2 arguments: self and self.domain.
            except UnicodeDecodeError:
#ANNOTATION: if except UnicodeDecodeError exception is caught,
                self.stdout.write("UnicodeDecodeError: skipped file %s in %s" % (f.file, f.dirpath))
#ANNOTATION: substitute '%s' in string "UnicodeDecodeError: skipped file %s in %s" with f.file and f.dirpath, write it to self.stdout.

        potfiles = []
#ANNOTATION: potfiles is an empty list.
        for path in self.locale_paths:
#ANNOTATION: for every path in self.locale_paths,
            potfile = os.path.join(path, '%s.pot' % str(self.domain))
#ANNOTATION: join into a path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string.
            if not os.path.exists(potfile):
#ANNOTATION: if potfile file path doesnt exist,
                continue
#ANNOTATION: skip this loop iteration.
            args = ['msguniq'] + self.msguniq_options + [potfile]
#ANNOTATION: append self.msguniq_options to a list containing a string 'msguniq', append list containing potfile to the result, substitute it for args.
            msgs, errors, status = popen_wrapper(args)
#ANNOTATION: call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.
            if six.PY2:
#ANNOTATION: if six.PY2 is true,
                msgs = msgs.decode('utf-8')
#ANNOTATION: call the method msgs.decode with an argument string 'utf-8', substitute it for msgs.
            if errors:
#ANNOTATION: if errors is true,
                if status != STATUS_OK:
#ANNOTATION: if status is not equal to STATUS_OK,
                    raise CommandError(
                        "errors happened while running msguniq\n%s" % errors)
#ANNOTATION: raise an CommandError exception with an argument string "errors happened while running msguniq\n%s", where '%s' is replaced with errors.
                elif self.verbosity > 0:
#ANNOTATION: otherwise if self.verbosity is greater than integer 0,
                    self.stdout.write(errors)
#ANNOTATION: write errors to self.stdout.
            with io.open(potfile, 'w', encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: potfile, string 'w' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
                fp.write(msgs)
#ANNOTATION: write msgs to fp.
            potfiles.append(potfile)
#ANNOTATION: append potfile to potfiles.
        return potfiles
#ANNOTATION: return potfiles.

    def remove_potfiles(self):
#ANNOTATION: define the method  remove_potfiles with an argument self.
        for path in self.locale_paths:
#ANNOTATION: for every path in self.locale_paths,
            pot_path = os.path.join(path, '%s.pot' % str(self.domain))
#ANNOTATION: join into a file path: path and string '%s.pot', where '%s' is replaced with self.domain converted into a string, substitute the result for pot_path.
            if os.path.exists(pot_path):
#ANNOTATION: if pot_path file path exists,
                os.unlink(pot_path)
#ANNOTATION: call the method os.unlink with an argument pot_path.

    def find_files(self, root):
#ANNOTATION: define the method find_potfiles with an arguments self and root.
        """
        Helper method to get all files in the given root. Also check that there
        is a matching locale dir for each file.
        """
#ANNOTATION: docstring

        def is_ignored(path, ignore_patterns):
#ANNOTATION: define the function is_ignored with arguments path and ignore_patterns.
            """
            Check if the given path should be ignored or not.
            """
#ANNOTATION: docstring
            filename = os.path.basename(path)
#ANNOTATION: call the function os.path.basename with an arguments path, substitute the result for filename.
            ignore = lambda pattern: fnmatch.fnmatchcase(filename, pattern)
#ANNOTATION: ignore is a lambda function with pattern as an argument, return value is the return value of the function fnmatch.fnmatchcase,
#ANNOTATION: called with arguments: filename and pattern.
            return any(ignore(pattern) for pattern in ignore_patterns)
#ANNOTATION: call the function ignore with an argument pattern, for every pattern in ignore_patterns, 
#ANNOTATION: if any resulting element is true, return boolean True, otherwise return boolean False.

        dir_suffix = '%s*' % os.sep
#ANNOTATION: convert os.sep into a string and append '*' to it, substitute the result for dir_suffix.
        norm_patterns = [p[:-len(dir_suffix)] if p.endswith(dir_suffix) else p for p in self.ignore_patterns]
#ANNOTATION: for p in self.ignore_patterns if p ends with dir_suffix take sliced list p from the start,
#ANNOTATION: to the negative length of the dir_suffix as the end index and append it to a list, 
#ANNOTATION: if p doesnt end with dir_suffix, append p to a list, substitute resulting list for norm_patterns. 
        all_files = []
#ANNOTATION: all_files is an empty list.
        for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):
#ANNOTATION: call the function os.walk with 3 arguments: root, topdown set to boolean True, followlinks set to self.symlinks,
#ANNOTATION: for every dirpath, dirnames and filenames in the result,
            for dirname in dirnames[:]:
#ANNOTATION: for every dirname in list dirnames,
                if is_ignored(os.path.normpath(os.path.join(dirpath, dirname)), norm_patterns):
#ANNOTATION: join dirpath and dirname into a file path, use is as an argument for the call to the function os.path.join,
#ANNOTATION: use the result as an argument for the call to the os.path.join function, 
#ANNOTATION: use the result and the norm_patterns as arguments for the call to the is_ignored function, if it evaluates to true,
                    dirnames.remove(dirname)
#ANNOTATION: remove dirname from the dirnames.
                    if self.verbosity > 1:
#ANNOTATION: if self.verbosity is greater than integer 1,
                        self.stdout.write('ignoring directory %s\n' % dirname)
#ANNOTATION: replace '%s' in string 'ignoring directory %s\n' with dirname, write it to self.stdout stream.
                elif dirname == 'locale':
#ANNOTATION: otherwise if dirname equals string 'locale',
                    dirnames.remove(dirname)
#ANNOTATION: remove dirname from the dirnames.
                    self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))
#ANNOTATION: call the method os.path.abspath with an argument dirpath, join the result and dirname into a file path, inset it at the beggining of self.locale_paths.
            for filename in filenames:
#ANNOTATION: for every filename in filenames,
                file_path = os.path.normpath(os.path.join(dirpath, filename))
#ANNOTATION: join dirpath and filename into path, use it as an argument for the call to the function os.path.normpath, substitute it for file_path.
                if is_ignored(file_path, self.ignore_patterns):
#ANNOTATION: call the function is_ignored, with arguments: file_path and self.ignore_patterns, if it evaluates to true,
                    if self.verbosity > 1:
#ANNOTATION: if self.verbosity is greater than integer 1,
                        self.stdout.write('ignoring file %s in %s\n' % (filename, dirpath))
#ANNOTATION: replace '%s' in string 'ignoring file %s in %s\n' with filename and dirpath, write it to self.stdout.
                else:
#ANNOTATION: if not,
                    locale_dir = None
#ANNOTATION: locale_dir is None.
                    for path in self.locale_paths:
#ANNOTATION: for every path in self.locale_paths,
                        if os.path.abspath(dirpath).startswith(os.path.dirname(path)):
#ANNOTATION: call the function os.path.abspath with an argument dirpath, if it starts with return value of the method os.path.dirname, 
#ANNOTATION: called with an argument path,
                            locale_dir = path
#ANNOTATION: substitute path for locale_dir.
                            break
#ANNOTATION: break the loop execution.
                    if not locale_dir:
#ANNOTATION: if locale_dir is false,
                        locale_dir = self.default_locale_path
#ANNOTATION: substitute self.default_locale_path for locale_dir.
                    if not locale_dir:
#ANNOTATION: if locale_dir is false,
                        raise CommandError(
                            "Unable to find a locale path to store translations for file %s" % file_path)
#ANNOTATION: raise an CommandError with an argument string "Unable to find a locale path to store translations for file %s",
#ANNOTATION: where '%s' is replaced with file_path.
                    all_files.append(TranslatableFile(dirpath, filename, locale_dir))
#ANNOTATION: create an object TranslatableFile with arguments: dirpath, filename and locale_dir, append it to all_files.
        return sorted(all_files)
#ANNOTATION: sort all_files and return it.

    def write_po_file(self, potfile, locale):
#ANNOTATION: define the method write_po_file with arguments self, potfile and locale.
        """
        Creates or updates the PO file for self.domain and :param locale:.
        Uses contents of the existing :param potfile:.

        Uses msgmerge, and msgattrib GNU gettext utilities.
        """
#ANNOTATION: docstring
        basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')
#ANNOTATION: call the method os.path.dirname with an argument potfile, join the result, locale and string 'LC_MESSAGES' into a file path,
#ANNOTATION: substitute it for basedir.
        if not os.path.isdir(basedir):
#ANNOTATION: if basedir is not a directory,
            os.makedirs(basedir)
#ANNOTATION: make basedir directory,
        pofile = os.path.join(basedir, '%s.po' % str(self.domain))
#ANNOTATION: convert self.domain into a string and append string '.po' to it, join basedir and result in file path, substitute it for pofile.

        if os.path.exists(pofile):
#ANNOTATION: if pofile path exists,
            args = ['msgmerge'] + self.msgmerge_options + [pofile, potfile]
#ANNOTATION: append self.msgmerge_options to a list containing string 'msgmerge', append to it a list containing pofile and potfile, substitute the result for args.
            msgs, errors, status = popen_wrapper(args)
#ANNOTATION: call the function popen_wrapper with an argument args, assign the result to msgs, errors and status.
            if six.PY2:
#ANNOTATION: if six.PY2 is true,
                msgs = msgs.decode('utf-8')
#ANNOTATION: call the method msgs.decode with an argument string 'utf-8', substitute the result for msgs.
            if errors:
#ANNOTATION: if errors is true,
                if status != STATUS_OK:
#ANNOTATION: if statue is not equal to STATUS_OK.
                    raise CommandError(
                        "errors happened while running msgmerge\n%s" % errors)
#ANNOTATION: raise an CommandError with an argument string "errors happened while running msgmerge\n%s", where '%s' is replaced with errors.
                elif self.verbosity > 0:
#ANNOTATION: otherwise if self.verbosity is greater than integer 0,
                    self.stdout.write(errors)
#ANNOTATION: write errors to self.stdout.
        else:
#ANNOTATION: if not,
            with io.open(potfile, 'r', encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: potfile, string 'r' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
                msgs = fp.read()
#ANNOTATION: read file fp and substitute the result for msgs.
            if not self.invoked_for_django:
#ANNOTATION: if self.invoked_for_django is false,
                msgs = self.copy_plural_forms(msgs, locale)
#ANNOTATION: call the method self.copy_plural_forms with arguments: msgs and locale, substitute it for msgs.
        msgs = msgs.replace(
            "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self.domain, "")
#ANNOTATION: substitute '%s' in string "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" with self.domain,
#ANNOTATION: replace all the occurrences of previous string in msgs for an empty string, substitute the result for msgs.
        with io.open(pofile, 'w', encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: pofile, string 'w' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
            fp.write(msgs)
#ANNOTATION: write msgs to fp.

        if self.no_obsolete:
#ANNOTATION: if self.no_obsolete is true,
            args = ['msgattrib'] + self.msgattrib_options + ['-o', pofile, pofile]
#ANNOTATION: append self.msgattrib_options to a list containing string 'msgattrib', append to it a list containing string '-o', pofile and pofile,
#ANNOTATION: substitute the result for args.
            msgs, errors, status = popen_wrapper(args)
#ANNOTATION: call the function popen_wrapper with an argument args, assign the result to msgs, errors and status, respectively.
            if errors:
#ANNOTATION: if errors is true,
                if status != STATUS_OK:
#ANNOTATION: if status is not equal to STATUS_OK,
                    raise CommandError(
                        "errors happened while running msgattrib\n%s" % errors)
#ANNOTATION: raise an CommandError with an argument string "errors happened while running msgattrib\n%s", where '%s' is replaced with errors.
                elif self.verbosity > 0:
#ANNOTATION: otherwise if self.verbosity is greater than integer 0,
                    self.stdout.write(errors)
#ANNOTATION: write errors to self.stdout.

    def copy_plural_forms(self, msgs, locale):
#ANNOTATION: define the method copy_plural_forms with arguments self, msgs and locale.
        """
        Copies plural forms header contents from a Django catalog of locale to
        the msgs string, inserting it at the right place. msgs should be the
        contents of a newly created .po file.
        """
#ANNOTATION: docstring
        django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))
#ANNOTATION: call the function os.path.dirname with an argument django.__file__, join the result into a path, 
#ANNOTATION: use it as an argument for the call to the function os.path.normpath, substitute the result for django_dir.
        if self.domain == 'djangojs':
#ANNOTATION: if self.domain equals a string 'djangojs',
            domains = ('djangojs', 'django')
#ANNOTATION: domains is a tuple with 2 elements: strings 'djangojs' and 'django'. 
        else:
#ANNOTATION: if not,
            domains = ('django',)
#ANNOTATION: domains is a tuple with element string 'django'. 
        for domain in domains:
#ANNOTATION:  for every domain in domains,
            django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)
#ANNOTATION: join into a file path: django_dir, 'conf', 'locale', locale, 'LC_MESSAGES' and string '.po' appended to domain, substitute the result for django_po.
            if os.path.exists(django_po):
#ANNOTATION: if django_po file path exists,
                with io.open(django_po, 'r', encoding='utf-8') as fp:
#ANNOTATION: call the function io.open with 3 arguments: django_po, string 'r' and encoding set to string 'utf-8' as arguments, 
#ANNOTATION: with the result renamed to fp, perform the following:
                    m = plural_forms_re.search(fp.read())
#ANNOTATION: read data from file fp, use the result as an argument for the call to the function plural_forms_re.search, substitute it for m.
                if m:
#ANNOTATION:  if m is true,
                    plural_form_line = force_str(m.group('value'))
#ANNOTATION: call the method m.group with an argument string 'value', use the result as an argument for the call to the force_str, 
#ANNOTATION: substitute the result for plural_form_line.
                    if self.verbosity > 1:
#ANNOTATION: if self.verbosity is greater than integer 1,
                        self.stdout.write("copying plural forms: %s\n" % plural_form_line)
#ANNOTATION: replace '%s' in string "copying plural forms: %s\n" with plural_form_line, write it to self.stdout.
                    lines = []
#ANNOTATION: lines is an empty list.
                    found = False
#ANNOTATION: found is boolean False.
                    for line in msgs.split('\n'):
#ANNOTATION: split msgs by newline characters, for every line in result,
                        if not found and (not line or plural_forms_re.search(line)):
#ANNOTATION: if found is false and, line is false or return value of the function plural_forms_re.search called with an argument line is false,
                            line = '%s\n' % plural_form_line
#ANNOTATION: append newline to plural_form_line, substitute the result for line.
                            found = True
#ANNOTATION: found is boolean True.
                        lines.append(line)
#ANNOTATION: append line to lines.
                    msgs = '\n'.join(lines)
#ANNOTATION: join elements of lines into a string, separated by newline characters, substitute it for msgs.
                    break
#ANNOTATION: break the loop execution.
        return msgs
#ANNOTATION: return msgs.
