# -*- coding: utf-8 -*-
from __future__ import unicode_literals
#ANNOTATION: from __future__ import unicode_literals into default name space.

from collections import OrderedDict
#ANNOTATION: from collections import OrderedDict into default name space.
from importlib import import_module
#ANNOTATION: from importlib import import_module into default name space.
import itertools
#ANNOTATION: import module itertools.
import traceback
#ANNOTATION: import module traceback.

from django.apps import apps
#ANNOTATION: from django.apps import apps into default name space.
from django.core.management import call_command
#ANNOTATION: from django.core.management import call_command into default name space.
from django.core.management.base import BaseCommand, CommandError
#ANNOTATION: from django.core.management.base import BaseCommand and CommandError into default name space.
from django.core.management.color import no_style
#ANNOTATION: from django.core.management.color import no_style into default name space.
from django.core.management.sql import custom_sql_for_model, emit_post_migrate_signal, emit_pre_migrate_signal
#ANNOTATION: from django.core.management.sql import custom_sql_for_model, emit_post_migrate_signal and emit_pre_migrate_signal into default name space.
from django.db import connections, router, transaction, DEFAULT_DB_ALIAS
#ANNOTATION: from django.db import connections,  router,  transaction and DEFAULT_DB_ALIAS into default name space.
from django.db.migrations.executor import MigrationExecutor
#ANNOTATION: from django.db.migrations.executor import MigrationExecutor into default name space.
from django.db.migrations.loader import MigrationLoader, AmbiguityError
#ANNOTATION: from django.db.migrations.loader import MigrationLoader and AmbiguityError into default name space.
from django.db.migrations.state import ProjectState
#ANNOTATION: from django.db.migrations.state import ProjectState into default name space.
from django.db.migrations.autodetector import MigrationAutodetector
#ANNOTATION: from django.db.migrations.autodetector import MigrationAutodetector into default name space.
from django.utils.module_loading import module_has_submodule
#ANNOTATION: from django.utils.module_loading import module_has_submodule into default name space.


class Command(BaseCommand):
#ANNOTATION: derive the class Command from the base class BaseCommand.
    help = "Updates database schema. Manages both apps with migrations and those without."
#ANNOTATION: help is a string "Updates database schema. Manages both apps with migrations and those without.".

    def add_arguments(self, parser):
#ANNOTATION: define the method add_arguments with self class instance and parse as the arguments.
        parser.add_argument('app_label', nargs='?',
            help='App label of an application to synchronize the state.')
#ANNOTATION: call the method parser.add_argument with string 'app_label', nargs set to charcter '?', help containing string,
#ANNOTATION: 'App label of an application to synchronize the state.' as arguments.
        parser.add_argument('migration_name', nargs='?',
            help='Database state will be brought to the state after that migration.')
#ANNOTATION: call the method parser.add_argument with string 'migration_name', nargs set to charcter '?', help containing string,
#ANNOTATION: 'Database state will be brought to the state after that migration.' as arguments.
        parser.add_argument('--noinput', action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind.')
#ANNOTATION: call the method parser.add_argument with string '--noinput', action containing string 'store_false', dest set to string 'interactive',
#ANNOTATION: default set to True, help containing string 'Tells Django to NOT prompt the user for input of any kind.' as arguments.
        parser.add_argument('--no-initial-data', action='store_false', dest='load_initial_data', default=True,
            help='Tells Django not to load any initial data after database synchronization.')
#ANNOTATION: call the method parser.add_argument with string '--no-initial-data', action containing string 'store_false', 
#ANNOTATION: dest set to string 'load_initial_data', default set to True,
#ANNOTATION: help containing string 'Tells Django not to load any initial data after database synchronization.' as arguments.
        parser.add_argument('--database', action='store', dest='database',
            default=DEFAULT_DB_ALIAS, help='Nominates a database to synchronize. '
                'Defaults to the "default" database.')
#ANNOTATION: call the method parser.add_argument with string '--database', action containing string 'store', dest set to string 'database',
#ANNOTATION: default set to DEFAULT_DB_ALIAS, help containing string 'Nominates a database to synchronize. Defaults to the "default" database.' as arguments.
        parser.add_argument('--fake', action='store_true', dest='fake', default=False,
            help='Mark migrations as run without actually running them')
#ANNOTATION: call the method parser.add_argument with string '--fake', action containing string 'store_true', dest set to string 'fake',
#ANNOTATION: default set to False, help containing string 'Mark migrations as run without actually running them' as arguments.
        parser.add_argument('--list', '-l', action='store_true', dest='list', default=False,
            help='Show a list of all known migrations and which are applied')
#ANNOTATION: call the method parser.add_argument with string '--list', string '-l', action contains string 'store_true', dest set to string 'list',
#ANNOTATION: default set to False, help containing string 'Show a list of all known migrations and which are applied' as arguments.

    def handle(self, *args, **options):
#ANNOTATION: define the method handle with self instance of a class, list args, dictionary options as arguments.

        self.verbosity = options.get('verbosity')
#ANNOTATION: get the value from the options dictionary under the key 'verbosity', substitute it for self.verbosity.
        self.interactive = options.get('interactive')
#ANNOTATION: get the value from the options dictionary under the key 'interactive', substitute it for self.interactive.
        self.show_traceback = options.get('traceback')
#ANNOTATION: get the value from the options dictionary under the key 'traceback', substitute it for self.show_traceback.
        self.load_initial_data = options.get('load_initial_data')
#ANNOTATION: get the value from the options dictionary under the key 'load_initial_data', substitute it for self.load_initial_data.
        self.test_database = options.get('test_database', False)
#ANNOTATION: get the value from the options dictionary under the key 'test_database', or False if the key dont exists, substitute it for self.test_database.

        # Import the 'management' module within each installed app, to register
        # dispatcher events.
        for app_config in apps.get_app_configs():
#ANNOTATION: for every app_config in return value of the call to the function apps.get_app_configs,
            if module_has_submodule(app_config.module, "management"):
#ANNOTATION: if call to the function module_has_submodule with app_config.module and "management" evaluates to True.
                import_module('.management', app_config.name)
#ANNOTATION: import module '.management' from the package app_config.name.

        # Get the database we're operating from
        db = options.get('database')
#ANNOTATION: get the value under the key 'database' of the options dictionary, substitute it for db.
        connection = connections[db]
#ANNOTATION: substitute connections element at the index of the value db for connections.

        # If they asked for a migration listing, quit main execution flow and show it
        if options.get("list", False):
#ANNOTATION: get the value under the 'list' key of options dictionary, if key doesnt exist return False, if the return value is True, 
            return self.show_migration_list(connection, [options['app_label']] if options['app_label'] else None)
#ANNOTATION: call the method self.show_migration_list with connection as first argument, as second argument use value under the 'app_label' key of options dictionary,
#ANNOTATION: if exists, if not use None as the second argument, return the result. 

        # Work out which apps have migrations and which do not
        executor = MigrationExecutor(connection, self.migration_progress_callback)
#ANNOTATION: call the function MigrationExecutor with connection and self.migration_progress_callback as arguments, substitute the result fro executor.

        # Before anything else, see if there's conflicting apps and drop out
        # hard if there are any
        conflicts = executor.loader.detect_conflicts()
#ANNOTATION: call the executor.loader.detect_conflicts, substitute the result fr conflicts.
        if conflicts:
#ANNOTATION: if conflicts is true,
            name_str = "; ".join(
                "%s in %s" % (", ".join(names), app)
                for app, names in conflicts.items()
            )
#ANNOTATION: for every app and names in key, value tuple pairs of conflicts dictionary join names into a string separated by commas,
#ANNOTATION: in "%s in %s" substitute '%s' with names string and app, respective, join all the previous pairs into a string separated by ';',
#ANNOTATION: substitute it for name_str. 
            raise CommandError("Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'" % name_str)
#ANNOTATION: raise CommandError exception, with "Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'",
#ANNOTATION: with '%s' substituted for name_str, as argument.

        # If they supplied command line arguments, work out what they mean.
        run_syncdb = False
#ANNOTATION: run_syncdb is boolean False.
        target_app_labels_only = True
#ANNOTATION: target_app_labels_only is boolean True.
        if options['app_label'] and options['migration_name']:
#ANNOTATION: if values under the 'app_label' and 'migration_name' keys of the options dictionary are True,
            app_label, migration_name = options['app_label'], options['migration_name']
#ANNOTATION: assign values under the 'app_label' and 'migration_name' keys of the options dictionary to the app_label and migration_name, respectively.
            if app_label not in executor.loader.migrated_apps:
#ANNOTATION: if app_label is not contained in executor.loader.migrated_apps,
                raise CommandError("App '%s' does not have migrations (you cannot selectively sync unmigrated apps)" % app_label)
#ANNOTATION: raise CommandError exception with "App '%s' does not have migrations (you cannot selectively sync unmigrated apps)",
#ANNOTATION: with '%s' substituted for app_label, as arguments.
            if migration_name == "zero":
#ANNOTATION: if migration_name equals to string 'zero',
                targets = [(app_label, None)]
#ANNOTATION: targets is a list containing tuple with two elements, app_label and None.
            else:
#ANNOTATION: if not,
                try:
#ANNOTATION: try,
                    migration = executor.loader.get_migration_by_prefix(app_label, migration_name)
#ANNOTATION: call the executor.loader.get_migration_by_prefix with app_label and migration_name, substitute the result for migration.
                except AmbiguityError:
#ANNOTATION: if AmbiguityError exception is caught,
                    raise CommandError("More than one migration matches '%s' in app '%s'. Please be more specific." % (
                        migration_name, app_label))
#ANNOTATION: raise CommandError exception with "More than one migration matches '%s' in app '%s'. Please be more specific.",
#ANNOTATION: with '%s' substituted for migration_name and app_label, respectively, as arguments.
                except KeyError:
#ANNOTATION: if KeyError exception is caught,
                    raise CommandError("Cannot find a migration matching '%s' from app '%s'." % (
                        migration_name, app_label))
#ANNOTATION: raise CommandError exception with "Cannot find a migration matching '%s' from app '%s'.",
#ANNOTATION: with '%s' substituted for migration_name and app_label, respectively, as arguments.
                targets = [(app_label, migration.name)]
#ANNOTATION: targets is a list containing tuple with two elements, app_label and migration.name.
            target_app_labels_only = False
#ANNOTATION: target_app_labels_only is boolean False.
        elif options['app_label']:
#ANNOTATION: otherwise if value under the 'app_label' key of options dictionary is true,
            app_label = options['app_label']
#ANNOTATION: substitute the value under the 'app_label' key of options dictionary for app_label.
            if app_label not in executor.loader.migrated_apps:
#ANNOTATION: if app_label is not contained in executor.loader.migrated_apps,
                raise CommandError("App '%s' does not have migrations (you cannot selectively sync unmigrated apps)" % app_label)
#ANNOTATION: raise CommandError exception with "App '%s' does not have migrations (you cannot selectively sync unmigrated apps)",
#ANNOTATION: with '%s' substituted for app_label, as arguments.
            targets = [key for key in executor.loader.graph.leaf_nodes() if key[0] == app_label]
#ANNOTATION: for every key in return vale of the method executor.loader.graph.leaf_nodes, check if the first element of key equals to app_label,
#ANNOTATION: if it does append it to targets list. 
        else:
#ANNOTATION: if not,
            targets = executor.loader.graph.leaf_nodes()
#ANNOTATION: call the method executor.loader.graph.leaf_nodes and substitute its result for targets.
            run_syncdb = True
#ANNOTATION: run_syncdb is boolean True.

        plan = executor.migration_plan(targets)
#ANNOTATION: call the executor.migration_plan method with targets as the argument, substitute the result for plan.

        # Print some useful info
        if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1.
            self.stdout.write(self.style.MIGRATE_HEADING("Operations to perform:"))
#ANNOTATION: call the self.style.MIGRATE_HEADING method, with string "Operations to perform:" as an argument,
#ANNOTATION: use the result as an argument for the call to the self.stdout.write method. 
            if run_syncdb and executor.loader.unmigrated_apps:
#ANNOTATION: if run_syncdb and executor.loader.unmigrated_apps exist,
                self.stdout.write(self.style.MIGRATE_LABEL("  Synchronize unmigrated apps: ") + (", ".join(executor.loader.unmigrated_apps)))
#ANNOTATION: join the executor.loader.unmigrated_apps into a string separated by string ', ' append it to the end of a string "  Synchronize unmigrated apps: ",
#ANNOTATION: use it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result of the previous method as an argument for the call to the self.stdout.write method.
            if target_app_labels_only:
#ANNOTATION: if target_app_labels_only is true,
                self.stdout.write(self.style.MIGRATE_LABEL("  Apply all migrations: ") + (", ".join(set(a for a, n in targets)) or "(none)"))
#ANNOTATION: for every a and n in targets, put a into a set, join all the set elements into a string separated by string ', ', 
#ANNOTATION: if set is empty return string '(none)' instead, append the previous to the string " Apply all migrations: ", 
#ANNOTATION: use the previous string as the argument for the call to the method self.style.MIGRATE_LABEL, 
#ANNOTATION: use the result as an argument for the call to the method self.stdout.write.
            else:
#ANNOTATION: if not,
                if targets[0][1] is None:
#ANNOTATION: if element of targets in first row and second column is None,
                    self.stdout.write(self.style.MIGRATE_LABEL("  Unapply all migrations: ") + "%s" % (targets[0][0], ))
#ANNOTATION: convert the first element of the first row of targets to string, append it to the string "  Unapply all migrations: ",
#ANNOTATION: use the it as an argument for the call to the self.style.MIGRATE_LABEL method, use the result to cal the self.stdout.write method.
                else:
#ANNOTATION: if not,
                    self.stdout.write(self.style.MIGRATE_LABEL("  Target specific migration: ") + "%s, from %s" % (targets[0][1], targets[0][0]))
#ANNOTATION: replace '%s' in string "%s, from %s" with second and first element of the first targets row, respectively,
#ANNOTATION: append it to the string "  Target specific migration: ", use it as the argument for the call to the self.style.MIGRATE_LABEL method,
#ANNOTATION: call the self.stdout.write method with previous return value as an argument.

        # Run the syncdb phase.
        # If you ever manage to get rid of this, I owe you many, many drinks.
        # Note that pre_migrate is called from inside here, as it needs
        # the list of models about to be installed.
        if run_syncdb and executor.loader.unmigrated_apps:
#ANNOTATION: if run_syncdb and executor.loader.unmigrated_apps is true,
            if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1.
                self.stdout.write(self.style.MIGRATE_HEADING("Synchronizing apps without migrations:"))
#ANNOTATION: call the self.style.MIGRATE_HEADING with string "Synchronizing apps without migrations:" as an argument,
#ANNOTATION: use the result as an argument for the call to the self.stdout.write.
            created_models = self.sync_apps(connection, executor.loader.unmigrated_apps)
#ANNOTATION: call the self.sync_apps method with connection and executor.loader.unmigrated_apps as arguments, substitute it for created_models. 
        else:
#ANNOTATION: if not,
            created_models = []
#ANNOTATION: create_models is an empty list.

        # The test runner requires us to flush after a syncdb but before migrations,
        # so do that here.
        if options.get("test_flush", False):
#ANNOTATION: if the value under the 'test_flush' key of the options dictionary exists,
            call_command(
                'flush',
                verbosity=max(self.verbosity - 1, 0),
                interactive=False,
                database=db,
                reset_sequences=False,
                inhibit_post_migrate=True,
            )
#ANNOTATION: call the function call_command with string 'flush', verbosity set to greater element, self.verbosity decremented by 1 or integer 0,
#ANNOTATION: interactive set to boolean False, database set to db, reset_sequences set to boolean False, inhibit_post_migrate set to boolean True.

        # Migrate!
        if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1,
            self.stdout.write(self.style.MIGRATE_HEADING("Running migrations:"))
#ANNOTATION: call the self.style.MIGRATE_HEADING method with string "Running migrations:" as an argument, use the result as an argument for the call to the self.stdout.write method.
        if not plan:
#ANNOTATION: if plan is not true,
            if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1,
                self.stdout.write("  No migrations to apply.")
#ANNOTATION: call the method self.stdout.write with string "  No migrations to apply." as an argument.
                # If there's changes that aren't in migrations yet, tell them how to fix it.
                autodetector = MigrationAutodetector(
                    executor.loader.project_state(),
                    ProjectState.from_apps(apps),
                )
#ANNOTATION: call the MigrationAutodetector function with arguments, return value of the call to the method executor.loader.project_state,
#ANNOTATION: and return value of the call to the method ProjectState.from_apps with apps as an argument, assign it to the autodetector.
                changes = autodetector.changes(graph=executor.loader.graph)
#ANNOTATION: call the method autodetector.changes with the graph set to executor.loader.graph as an argument, substitute it for the changes.
                if changes:
#ANNOTATION: if changes is true,
                    self.stdout.write(self.style.NOTICE("  Your models have changes that are not yet reflected in a migration, and so won't be applied."))
#ANNOTATION: call the method self.style.NOTICE with string "  Your models have changes that are not yet reflected in a migration, and so won't be applied." as an argument, use the result as an argument for the call to the self.stdout.write method.
                    self.stdout.write(self.style.NOTICE("  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them."))
#ANNOTATION: call the method self.style.NOTICE with string "  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them." as an argument, use the result as an argument for the call to the self.stdout.write method.
        else:
#ANNOTATION: if not,
            executor.migrate(targets, plan, fake=options.get("fake", False))
#ANNOTATION: call the executor.migrate method with, targets, plan and fake set to the value under the 'fake' key of options dictionary,
#ANNOTATION: if the 'fake' key doesnt exists set fake to boolean False, as arguments.

        # Send the post_migrate signal, so individual apps can do whatever they need
        # to do at this point.
        emit_post_migrate_signal(created_models, self.verbosity, self.interactive, connection.alias)
#ANNOTATION: call the method emit_post_migrate_signal with created_models, self.verbosity, self.interactive and connection.alias as arguments.

    def migration_progress_callback(self, action, migration, fake=False):
#ANNOTATION: define the method migration_progress_callback with self class instance, action, migration and fake set to boolean False as arguments.
        if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1, 
            if action == "apply_start":
#ANNOTATION: if action equals to string "apply_start",
                self.stdout.write("  Applying %s..." % migration, ending="")
#ANNOTATION: call the self.stdout.write method, with string "  Applying %s..." with '%s' replaced with migration and ending set to '', as arguments.
 
                self.stdout.flush()
#ANNOTATION: flush the output buffer of the self.stdout object.
            elif action == "apply_success":
#ANNOTATION: otherwise if action equals to string 'apply_success', 
                if fake:
#ANNOTATION: if fake is true,
                    self.stdout.write(self.style.MIGRATE_SUCCESS(" FAKED"))
#ANNOTATION: wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string " FAKED" as a argument. 
                else:
#ANNOTATION: if not,
                    self.stdout.write(self.style.MIGRATE_SUCCESS(" OK"))
#ANNOTATION: wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string " OK" as a argument. 
            elif action == "unapply_start":
#ANNOTATION: otherwise if action equals to string 'unapply_start'.
                self.stdout.write("  Unapplying %s..." % migration, ending="")
#ANNOTATION: call the self.stdout.write method, with string "  Unapplying %s..." with '%s' replaced with migration and ending set to '', as arguments.
                self.stdout.flush()
#ANNOTATION: flush the output buffer of the self.stdout object.
            elif action == "unapply_success":
#ANNOTATION: otherwise if action equals to string "unapply_success".
                if fake:
#ANNOTATION: if fake is true,
                    self.stdout.write(self.style.MIGRATE_SUCCESS(" FAKED"))
#ANNOTATION: wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string " FAKED" as a argument. 
                else:
#ANNOTATION: if not,
                    self.stdout.write(self.style.MIGRATE_SUCCESS(" OK"))
#ANNOTATION: wrte to the standard output result of the call to the method self.style.MIGRATE_SUCCESS with string " OK" as a argument. 

    def sync_apps(self, connection, app_labels):
#ANNOTATION: define the method sync_apps with self class instance, connection and app_labels as arguments.
        "Runs the old syncdb-style operation on a list of app_labels."
#ANNOTATION: docstring
        cursor = connection.cursor()
#ANNOTATION: call the connection.cursor method, substitute the result for cursor.

        try:
#ANNOTATION: try,
            # Get a list of already installed *models* so that references work right.
            tables = connection.introspection.table_names(cursor)
#ANNOTATION: call the connection.introspection.table_names with cursor as argument, store the result in tables.
            seen_models = connection.introspection.installed_models(tables)
#ANNOTATION: call the connection.introspection.table_names with tables as argument, store the result in seen_models.
            created_models = set()
#ANNOTATION: created_models is a set.
            pending_references = {}
#ANNOTATION: pending_references is a empty dictionary.

            # Build the manifest of apps and models that are to be synchronized
            all_models = [
                (app_config.label,
                    router.get_migratable_models(app_config, connection.alias, include_auto_created=True))
                for app_config in apps.get_app_configs()
                if app_config.models_module is not None and app_config.label in app_labels
            ]
#ANNOTATION: for every app_config in return value of the method apps.get_app_configs if app_config.models_module is not None,
#ANNOTATION: and app_config.label is contained in app_labels, create a tuple containing app_config.label and return value of the method
#ANNOTATION: router.get_migratable_models called with app_config, connection.alias and include_auto_created set to True, append the tuple to the list all_models.

            def model_installed(model):
#ANNOTATION: define the method model_installed with model as an argument. 
                opts = model._meta
#ANNOTATION: substitute model._meta for opts.
                converter = connection.introspection.table_name_converter
#ANNOTATION: substitute connection.introspection.table_name_converter for converter.
                # Note that if a model is unmanaged we short-circuit and never try to install it
                return not ((converter(opts.db_table) in tables) or
                    (opts.auto_created and converter(opts.auto_created._meta.db_table) in tables))
#ANNOTATION: evaluate next boolean expression, value of converter function with opts.db_table as argument is contained in tables, 
#ANNOTATION: or opts.auto_created is True and return value of converter function with opts.auto_created._meta.db_table is contained in tables,
#ANNOTATION: invert the evaluated expression and return it.

            manifest = OrderedDict(
                (app_name, list(filter(model_installed, model_list)))
                for app_name, model_list in all_models
            )
#ANNOTATION: manifest is OrderDict class instance, created with tuple of two elements, app_name and list of elements of model_list for which model_installed function returned true, for every app_name and model_list in all_modules.

            create_models = set(itertools.chain(*manifest.values()))
#ANNOTATION: unpack the manifest.values function return value and feed it to the itertools.chain function, create_models is a set containing chanied list.
            emit_pre_migrate_signal(create_models, self.verbosity, self.interactive, connection.alias)
#ANNOTATION: call the emit_pre_migrate_signal with create_models, self.verbosity, self.interactive. connection.alias as arguments.

            # Create the tables for each model
            if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal than integer 1,
                self.stdout.write("  Creating tables...\n")
#ANNOTATION: write the string "  Creating tables...\n" to the standard output.
            with transaction.atomic(using=connection.alias, savepoint=connection.features.can_rollback_ddl):
#ANNOTATION: with the call to the transaction.atomic method with using set to connection.alias, savepoint set to connection.features.can_rollback_ddl as arguments,
                for app_name, model_list in manifest.items():
#ANNOTATION: for every app_name and model_list in return value of manifest.items function,
                    for model in model_list:
#ANNOTATION: for every model in model_list,
                        # Create the model's database table, if it doesn't already exist.
                        if self.verbosity >= 3:
#ANNOTATION: if self.verbosity is greater or equal to 3,
                            self.stdout.write("    Processing %s.%s model\n" % (app_name, model._meta.object_name))
#ANNOTATION: call the self.stdout.write method with string "    Processing %s.%s model\n" as argument, with all occurrences of '%s' replaced with,
#ANNOTATION: app_name and model._meta.object_name, respectively.
                        sql, references = connection.creation.sql_create_model(model, no_style(), seen_models)
#ANNOTATION: evaluate connection.creation.sql_create_model method with model, no_style() and seen_models as arguments,
#ANNOTATION: assign the result to the sql and references, respectively.
                        seen_models.add(model)
#ANNOTATION: add model to seen_models set.
                        created_models.add(model)
#ANNOTATION: add model to created_models set.
                        for refto, refs in references.items():
#ANNOTATION: for every refto and refs in return value of references.items method.
                            pending_references.setdefault(refto, []).extend(refs)
#ANNOTATION: call the method extend with refs as argument, on the result call the pending_references.setdefault method with refto and empty list as arguments.
                            if refto in seen_models:
#ANNOTATION: if refto is contained in seen_models,
                                sql.extend(connection.creation.sql_for_pending_references(refto, no_style(), pending_references))
#ANNOTATION: call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,
#ANNOTATION: use the result as the argument for the call to the sql.extend method.
                        sql.extend(connection.creation.sql_for_pending_references(model, no_style(), pending_references))
#ANNOTATION: call the connection.creation.sql_for_pending_references method with refto, no_style() and pending_references as arguments,
#ANNOTATION: use the result as the argument for the call to the sql.extend method.
                        if self.verbosity >= 1 and sql:
#ANNOTATION: if self.verbosity is greater or equal than integer 1 and sql is true,
                            self.stdout.write("    Creating table %s\n" % model._meta.db_table)
#ANNOTATION: call the self.stdout.write method with string "    Creating table %s\n" as argument, with all occurrences of '%s' replaced with model._meta.db_table.
                        for statement in sql:
#ANNOTATION: for statements is sql,
                            cursor.execute(statement)
#ANNOTATION: call the cursor.execute method with statement as argument.
                        tables.append(connection.introspection.table_name_converter(model._meta.db_table))
#ANNOTATION: evaluate the method connection.introspection.table_name_converter with model._meta.db_table as argument, append it to tables.
        finally:
#ANNOTATION: finally, perform,
            cursor.close()
#ANNOTATION: call the cursor.close method.

        # The connection may have been closed by a syncdb handler.
        cursor = connection.cursor()
#ANNOTATION: call the connection.cursor method, substitute it for cursor.
        try:
#ANNOTATION: try,
            # Install custom SQL for the app (but only if this
            # is a model we've just created)
            if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal than integer 1,
                self.stdout.write("  Installing custom SQL...\n")
#ANNOTATION: write the string "  Installing custom SQL...\n" to the standard output.
            for app_name, model_list in manifest.items():
#ANNOTATION: for every app_name and mode_list in return value of manifest.items method,
                for model in model_list:
#ANNOTATION: for model in model_list,
                    if model in created_models:
#ANNOTATION: if model is contained in created_models,
                        custom_sql = custom_sql_for_model(model, no_style(), connection)
#ANNOTATION: call the method custom_sql_for_model with model, no_style() and connection as arguments, substitute the result for custom_sql.
                        if custom_sql:
#ANNOTATION: if custom_sql is empty,
                            if self.verbosity >= 2:
#ANNOTATION: if self.verbosity is greater or equal to integer 2,
                                self.stdout.write("    Installing custom SQL for %s.%s model\n" % (app_name, model._meta.object_name))
#ANNOTATION: call the self.stdout.write method with string "    Installing custom SQL for %s.%s model\n" as argument, 
#ANNOTATION: with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.
                            try:
#ANNOTATION: try,
                                with transaction.atomic(using=connection.alias):
#ANNOTATION: with call to the function transaction.atomic with using set to connection.alias as argument,
                                    for sql in custom_sql:
#ANNOTATION: for every sql in custom_sql,
                                        cursor.execute(sql)
#ANNOTATION: call the cursor.execute method with sql as argument.
                            except Exception as e:
#ANNOTATION: if exception of class Exception, as e, is caught,  
                                self.stderr.write("    Failed to install custom SQL for %s.%s model: %s\n" % (app_name, model._meta.object_name, e))
#ANNOTATION: call the self.stderr.write method with string "    Failed to install custom SQL for %s.%s model: %s\n" as argument, 
#ANNOTATION: with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively.
                                if self.show_traceback:
#ANNOTATION: if self.show_traceback is true,
                                    traceback.print_exc()
#ANNOTATION: call the traceback.print_exc method.
                        else:
#ANNOTATION: if not,
                            if self.verbosity >= 3:
#ANNOTATION: if self.verbosity is greater or equal to integer 3,
                                self.stdout.write("    No custom SQL for %s.%s model\n" % (app_name, model._meta.object_name))
#ANNOTATION: call the self.stderr.write method with string "    No custom SQL for %s.%s model\n" as argument, 
#ANNOTATION: with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.

            if self.verbosity >= 1:
#ANNOTATION: if self.verbosity is greater or equal to integer 1,
                self.stdout.write("  Installing indexes...\n")
#ANNOTATION: write string "  Installing indexes...\n" to the standard output.

            # Install SQL indices for all newly created models
            for app_name, model_list in manifest.items():
#ANNOTATION: for every app_name and model_list in return value of manifest.items method,
                for model in model_list:
#ANNOTATION: for every model in model_list,
                    if model in created_models:
#ANNOTATION: if model is contained in created_models,
                        index_sql = connection.creation.sql_indexes_for_model(model, no_style())
#ANNOTATION: call the connection.creation.sql_indexes_for_model with model and no_style() as arguments, substitute the result for index_squl.
                        if index_sql:
#ANNOTATION: if index_sql is not empty,
                            if self.verbosity >= 2:
#ANNOTATION: if self.verbosity is greater or equal to integer 2,
                                self.stdout.write("    Installing index for %s.%s model\n" % (app_name, model._meta.object_name))
#ANNOTATION: call the self.stderr.write method with string "    Installing index for %s.%s model\n" as argument, 
#ANNOTATION: with all occurrences of '%s' replaced with app_name and model._meta.object_name, respectively.
                            try:
#ANNOTATION: try,
                                with transaction.atomic(using=connection.alias, savepoint=connection.features.can_rollback_ddl):
#ANNOTATION: with call to the function transaction.atomic with using set to connection.alias and savepoint set to connection.features.can_rollback_ddl, as arguments.
                                    for sql in index_sql:
#ANNOTATION: for every sql in index_sql,
                                        cursor.execute(sql)
#ANNOTATION: call the method cursor.execute with sql as argument.
                            except Exception as e:
#ANNOTATION: if exception of the class Exception, as e, is caught,
                                self.stderr.write("    Failed to install index for %s.%s model: %s\n" % (app_name, model._meta.object_name, e))
#ANNOTATION: call the self.stderr.write method with string "    Failed to install index for %s.%s model: %s\n" as argument, 
#ANNOTATION: with all occurrences of '%s' replaced with app_name and model._meta.object_name and e, respectively.
        finally:
#ANNOTATION: finally perform,
            cursor.close()
#ANNOTATION: call the cursor.close method.

        # Load initial_data fixtures (unless that has been disabled)
        if self.load_initial_data:
#ANNOTATION: if self.load_initial_data is not empty,
            for app_label in app_labels:
#ANNOTATION: for every app_label in app_labels,
                call_command('loaddata', 'initial_data', verbosity=self.verbosity, database=connection.alias, skip_validation=True, app_label=app_label, hide_empty=True)
#ANNOTATION: call the method call_command with string 'loaddata', string 'initial_data', verbosity set to self.verbosity, 
#ANNOTATION: database set to connection.alias, skip_validation set to boolean True, app_label set to app_label and hide_empty set to boolean True.

        return created_models
#ANNOTATION: return created_models

    def show_migration_list(self, connection, app_names=None):
#ANNOTATION: define show_migration_list with self class instance, connection and app_names set to None, as arguments.
        """
        Shows a list of all migrations on the system, or only those of
        some named apps.
        """
#ANNOTATION: docstring
        # Load migrations from disk/DB
        loader = MigrationLoader(connection)
#ANNOTATION: loader is instance of MigrationLoader initialized with connection as an argument.
        graph = loader.graph
#ANNOTATION: substitute loader.graph for graph.
        # If we were passed a list of apps, validate it
        if app_names:
#ANNOTATION: if app_names is not empty,
            invalid_apps = []
#ANNOTATION: invalid_apps is an empty list.
            for app_name in app_names:
#ANNOTATION: for every app_name is app_names,
                if app_name not in loader.migrated_apps:
#ANNOTATION: if app_name is not contained in loader.migrated_apps,
                    invalid_apps.append(app_name)
#ANNOTATION: append app_name to the invalid_apps.
            if invalid_apps:
#ANNOTATION: if invalid_apps in not empty,
                raise CommandError("No migrations present for: %s" % (", ".join(invalid_apps)))
#ANNOTATION: raise a CommandError exception, with string "No migrations present for: %s" as argument, substitute '%s' in previous string with,
#ANNOTATION: string joined from invalided_apps list and separated with string ', '.
        # Otherwise, show all apps in alphabetic order
        else:
#ANNOTATION: if not,
            app_names = sorted(loader.migrated_apps)
#ANNOTATION: sort loader.migrated_apps, substitute it for app_names.
        # For each app, print its migrations in order from oldest (roots) to
        # newest (leaves).
        for app_name in app_names:
#ANNOTATION: for every app_name in app_names.
            self.stdout.write(app_name, self.style.MIGRATE_LABEL)
#ANNOTATION: call self.stdout.write method with app_name and self.style.MIGRATE_LABEL as arguments.
            shown = set()
#ANNOTATION: shown is an empty set.
            for node in graph.leaf_nodes(app_name):
#ANNOTATION: for every node in return value of the graph.leaf_nodes method called with the app_name argument,
                for plan_node in graph.forwards_plan(node):
#ANNOTATION: for every plan_node in return value of the graph.forwards_plan method called with node as argument.
                    if plan_node not in shown and plan_node[0] == app_name:
#ANNOTATION: if plan_node is not contained in shown and first element of plan_node equals to app_name, 
                        # Give it a nice title if it's a squashed one
                        title = plan_node[1]
#ANNOTATION: substitute second element of plan_node for title.
                        if graph.nodes[plan_node].replaces:
#ANNOTATION: if replaces filed of graph.nodes element at the plan_node index is true,
                            title += " (%s squashed migrations)" % len(graph.nodes[plan_node].replaces)
#ANNOTATION: substitute '%s' in the string " (%s squashed migrations)" with length of replaces filed of graph.nodes element at the plan_node index, append the string to the title.  
                        # Mark it as applied/unapplied
                        if plan_node in loader.applied_migrations:
#ANNOTATION: if plan_node is contained in loader.applied_migrations,
                            self.stdout.write(" [X] %s" % title)
#ANNOTATION: substitute '%s' with title in the string " [X] %s", write it to the standard output.
                        else:
#ANNOTATION: if not,
                            self.stdout.write(" [ ] %s" % title)
#ANNOTATION: substitute '%s' with title in the string " [ ] %s", write it to the standard output.
                        shown.add(plan_node)
#ANNOTATION: add plan_node to the shown set.
            # If we didn't print anything, then a small message
            if not shown:
#ANNOTATION: if shown is an empty set,
                self.stdout.write(" (no migrations)", self.style.MIGRATE_FAILURE)
#ANNOTATION: call the self.stdout.write method with string " (no migrations)" and self.style.MIGRATE_FAILURE as arguments.
