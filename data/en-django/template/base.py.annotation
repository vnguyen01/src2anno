from __future__ import unicode_literals
#ANNOTATION: from __future__ import unicode_literals into default name space.

import re
#ANNOTATION: import module re.
from functools import partial
#ANNOTATION: from functools import partial into default name space.
from importlib import import_module
#ANNOTATION: from importlib import import_module into default name space.
from inspect import getargspec, getcallargs
#ANNOTATION: from inspect import getargspec and getcallargs into default name space.
import warnings
#ANNOTATION: import module warnings.

from django.apps import apps
#ANNOTATION: from django.apps import apps into default name space.
from django.conf import settings
#ANNOTATION: from django.conf import settings into default name space.
from django.template.context import (BaseContext, Context, RequestContext,  # NOQA: imported for backwards compatibility
    ContextPopException)
#ANNOTATION: from django.template.context import BaseContext, Context, RequestContext and ContextPopException into default namespace.
from django.utils.deprecation import RemovedInDjango20Warning
#ANNOTATION: from django.utils.deprecation import RemovedInDjango20Warning into default name space.
from django.utils.itercompat import is_iterable
#ANNOTATION: from django.utils.itercompat import is_iterable into default name space.
from django.utils.text import (smart_split, unescape_string_literal,
    get_text_list)
#ANNOTATION: from django.utils.text import smart_split, unescape_string_literal and get_text_list into default namespace.
from django.utils.encoding import force_str, force_text
#ANNOTATION: from django.utils.encoding import force_str and force_text into default name space.
from django.utils.translation import ugettext_lazy, pgettext_lazy
#ANNOTATION: from django.utils.translation import ugettext_lazy and pgettext_lazy into default name space.
from django.utils.safestring import (SafeData, EscapeData, mark_safe,
    mark_for_escaping)
#ANNOTATION: from django.utils.safestring import SafeData, EscapeData, mark_safe and mark_for_escaping into default namespace.
from django.utils.formats import localize
#ANNOTATION: from django.utils.formats import localize into default name space.
from django.utils.html import escape
#ANNOTATION: from django.utils.html import escape into default name space.
from django.utils.module_loading import module_has_submodule
#ANNOTATION: from django.utils.module_loading import module_has_submodule into default name space.
from django.utils import six
#ANNOTATION: from django.utils import six into default name space.
from django.utils.timezone import template_localtime
#ANNOTATION: from django.utils.timezone import template_localtime into default name space.
from django.utils.encoding import python_2_unicode_compatible
#ANNOTATION: from django.utils.encoding import python_2_unicode_compatible into default name space.


TOKEN_TEXT = 0
#ANNOTATION: TOKEN_TEXT is integer 0
TOKEN_VAR = 1
#ANNOTATION: TOKEN_VAR is integer 1
TOKEN_BLOCK = 2
#ANNOTATION: TOKEN_BLOCK is integer 2
TOKEN_COMMENT = 3
#ANNOTATION: TOKEN_COMMENT is integer 3.
TOKEN_MAPPING = {
    TOKEN_TEXT: 'Text',
    TOKEN_VAR: 'Var',
    TOKEN_BLOCK: 'Block',
    TOKEN_COMMENT: 'Comment',
}
#ANNOTATION: TOKEN_MAPPING is a dictionary with 4 initial entries: 'Text' for TOKEN_TEXT, 'Var' for TOKEN_VAR, 'Block' for TOKEN_BLOCK,
#ANNOTATION: and 'Comment' for TOKEN_COMMENT.

# template syntax constants
FILTER_SEPARATOR = '|'
#ANNOTATION: FILTER_SEPARATOR is a string '|'.
FILTER_ARGUMENT_SEPARATOR = ':'
#ANNOTATION: FILTER_ARGUMENT_SEPARATOR is a string ':'.
VARIABLE_ATTRIBUTE_SEPARATOR = '.'
#ANNOTATION: VARIABLE_ATTRIBUTE_SEPARATOR is a string '.'.
BLOCK_TAG_START = '{%'
#ANNOTATION: BLOCK_TAG_START is a string '{%'.
BLOCK_TAG_END = '%}'
#ANNOTATION: BLOCK_TAG_END is a string '%}'.
VARIABLE_TAG_START = '{{'
#ANNOTATION: VARIABLE_TAG_START is a string '{{'.
VARIABLE_TAG_END = '}}'
#ANNOTATION: VARIABLE_TAG_END is a string '}}'.
COMMENT_TAG_START = '{#'
#ANNOTATION: COMMENT_TAG_START is a string '{#'.
COMMENT_TAG_END = '#}'
#ANNOTATION: COMMENT_TAG_END is a string '#}'.
TRANSLATOR_COMMENT_MARK = 'Translators'
#ANNOTATION: TRANSLATOR_COMMENT_MARK is a string 'Translators'.
SINGLE_BRACE_START = '{'
#ANNOTATION: SINGLE_BRACE_START is a string '{'.
SINGLE_BRACE_END = '}'
#ANNOTATION: SINGLE_BRACE_END is a string '}'.

ALLOWED_VARIABLE_CHARS = ('abcdefghijklmnopqrstuvwxyz'
                         'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.')
#ANNOTATION: ALLOWED_VARIABLE_CHARS is a string 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.'.

# what to report as the origin for templates that come from non-loader sources
# (e.g. strings)
UNKNOWN_SOURCE = '<unknown source>'
#ANNOTATION: UNKNOWN_SOURCE is a string '<unknown source>'.

# match a variable or block tag and capture the entire tag, including start/end
# delimiters
tag_re = (re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' %
          (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END),
           re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END),
           re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END))))
#ANNOTATION: call the function re.compile with an argument string '(%s.*?%s|%s.*?%s|%s.*?%s)', substitute all occurrences of '%s' with,
#ANNOTATION: return value of the function re.escape called with an argument BLOCK_TAG_START,
#ANNOTATION: return value of the function re.escape called with an argument BLOCK_TAG_END,
#ANNOTATION: return value of the function re.escape called with an argument VARIABLE_TAG_START,
#ANNOTATION: return value of the function re.escape called with an argument VARIABLE_TAG_END,
#ANNOTATION: return value of the function re.escape called with an argument COMMENT_TAG_START,
#ANNOTATION: and return value of the function re.escape called with an argument COMMENT_TAG_END, substitute the result for tag_re.



# global dictionary of libraries that have been loaded using get_library
libraries = {}
#ANNOTATION: libraries is an empty dictionary. 
# global list of libraries to load by default for a new parser
builtins = []
#ANNOTATION: builtins is an empty list. 

# True if TEMPLATE_STRING_IF_INVALID contains a format string (%s). None means
# uninitialized.
invalid_var_format_string = None
#ANNOTATION: invalid_var_format_string is None.


class TemplateSyntaxError(Exception):
#ANNOTATION: derive the class TemplateSyntaxError form the base class Exception.
    pass
#ANNOTATION: do nothing.


class TemplateDoesNotExist(Exception):
#ANNOTATION: derive the class TemplateDoesNotExist form the base class Exception.
    pass
#ANNOTATION: do nothing.


class TemplateEncodingError(Exception):
#ANNOTATION: derive the class TemplateEncodingError form the base class Exception.
    pass
#ANNOTATION: do nothing.


@python_2_unicode_compatible
#ANNOTATION: python_2_unicode_compatible decorator,
class VariableDoesNotExist(Exception):
#ANNOTATION: derive the class VariableDoesNotExist form the base class Exception.

    def __init__(self, msg, params=()):
#ANNOTATION: define the method __init__ with 3 arguments: self, msg and params set to an empty tuple.
        self.msg = msg
#ANNOTATION: substitute msg for self.msg.
        self.params = params
#ANNOTATION: substitute params for self.params.

    def __str__(self):
#ANNOTATION: define the method __str__ with an argument self.
        return self.msg % tuple(force_text(p, errors='replace') for p in self.params)
#ANNOTATION: return self.msg formatted with a tuple, with elements generated from return value of the function force_text with 2 arguments:
#ANNOTATION: p and errors set to string 'replace', for p in self.params.


class InvalidTemplateLibrary(Exception):
#ANNOTATION: derive the class InvalidTemplateLibrary form the base class Exception.
    pass
#ANNOTATION: do nothing.


class Origin(object):
#ANNOTATION: derive the class Origin form the base class object.
    def __init__(self, name):
#ANNOTATION: define the method __init__ with 2 arguments: self and name.
        self.name = name
#ANNOTATION: substitute name for self.name.

    def reload(self):
#ANNOTATION: define the method reload with an argument self.
        raise NotImplementedError('subclasses of Origin must provide a reload() method')
#ANNOTATION: raise an NotImplementedError exception with an argument string 'subclasses of Origin must provide a reload() method'.

    def __str__(self):
#ANNOTATION: define the method with reload with an argument self.
        return self.name
#ANNOTATION: return self.name.


class StringOrigin(Origin):
#ANNOTATION: derive the class StringOrigin form the base class Origin.
    def __init__(self, source):
#ANNOTATION: define the method __init__ with 2 arguments: self and source.
        super(StringOrigin, self).__init__(UNKNOWN_SOURCE)
#ANNOTATION: call the method __init__ with an argument UNKNOWN_SOURCE, from the base class of the class StringOrigin.
        self.source = source
#ANNOTATION: substitute source for self.source.

    def reload(self):
#ANNOTATION: define the method with reload with an argument self.
        return self.source
#ANNOTATION: return self.source.


class Template(object):
#ANNOTATION: derive the class Template form the base class object.
    def __init__(self, template_string, origin=None, name=None):
#ANNOTATION: define the method __init__ with 4 arguments: self, template_string, origin set to None and name set to None.
        try:
#ANNOTATION: try,
            template_string = force_text(template_string)
#ANNOTATION: call the function force_text with an argument template_string.
        except UnicodeDecodeError:
#ANNOTATION: if UnicodeDecodeError exception is caught,
            raise TemplateEncodingError("Templates can only be constructed "
                                        "from unicode or UTF-8 strings.")
#ANNOTATION: raise an TemplateEncodingError exception with an argument "Templates can only be constructed from unicode or UTF-8 strings.".
        if settings.TEMPLATE_DEBUG and origin is None:
#ANNOTATION: if settings.TEMPLATE_DEBUG is true and origin is None,
            origin = StringOrigin(template_string)
#ANNOTATION: origin is an instance of StringOrigin class created with an argument template_string. 
        self.nodelist = compile_string(template_string, origin)
#ANNOTATION: call the function compile_string with 2 arguments: template_string and origin, substitute the result for self.nodelist.
        self.name = name
#ANNOTATION: substitute name for self.name.
        self.origin = origin
#ANNOTATION: substitute origin for self.origin.

    def __iter__(self):
#ANNOTATION: define the method __iter__ with an argument self.
        for node in self.nodelist:
#ANNOTATION: for every node in self.nodelist,
            for subnode in node:
#ANNOTATION: for every subnode in node,
                yield subnode
#ANNOTATION: yield subnode.

    def _render(self, context):
#ANNOTATION: define the method _render with 2 arguments self and context.
        return self.nodelist.render(context)
#ANNOTATION: call the method self.nodelist.render with an argument context, return the result.

    def render(self, context):
#ANNOTATION: define the method render with 2 arguments self and context.
        "Display stage -- can be called many times"
#ANNOTATION: docstring
        context.render_context.push()
#ANNOTATION: call the method context.render_context.push.
        try:
#ANNOTATION: try, 
            return self._render(context)
#ANNOTATION: call the method self._render with an argument context, return the result,
        finally:
#ANNOTATION: finally perform,
            context.render_context.pop()
#ANNOTATION: remove the first element from context.render_context.


def compile_string(template_string, origin):
#ANNOTATION: define the method compile_string with 2 arguments: template_string and origin.
    "Compiles template_string into NodeList ready for rendering"
#ANNOTATION: docstring
    if settings.TEMPLATE_DEBUG:
#ANNOTATION: if settings.TEMPLATE_DEBUG is true,
        from django.template.debug import DebugLexer, DebugParser
#ANNOTATION: from django.template.debug import DebugLexer and DebugParser.
        lexer_class, parser_class = DebugLexer, DebugParser
#ANNOTATION: substitute DebugLexer and DebugParser for lexer_class and parser_class.
    else:
#ANNOTATION: if not,
        lexer_class, parser_class = Lexer, Parser
#ANNOTATION: substitute Lexer and Parser for lexer_class and parser_class.
    lexer = lexer_class(template_string, origin)
#ANNOTATION: call the method lexer_class with an arguments template_string and origin, substitute the result for lexer.
    parser = parser_class(lexer.tokenize())
#ANNOTATION: call the method lexer.tokenize, use it as an argument for the call to the parser_class function, substitute the result for parser.
    return parser.parse()
#ANNOTATION: call the method parser.parse, return the result.


class Token(object):
#ANNOTATION: derive the class Token form the base class object.
    def __init__(self, token_type, contents):
#ANNOTATION: define the method __init__ with 3 arguments: self, token_type and contents.
        # token_type must be TOKEN_TEXT, TOKEN_VAR, TOKEN_BLOCK or
        # TOKEN_COMMENT.
        self.token_type, self.contents = token_type, contents
#ANNOTATION: substitute token_type and contents for self.token_type and self.contents.
        self.lineno = None
#ANNOTATION: self.lineno is None.

    def __str__(self):
#ANNOTATION: define the method __str__ with an argument self.
        token_name = TOKEN_MAPPING[self.token_type]
#ANNOTATION: substitute value under the self.token_type key of the TOKEN_MAPPING dictionary for token_name.
        return ('<%s token: "%s...">' %
                (token_name, self.contents[:20].replace('\n', '')))
#ANNOTATION: return a string '<%s token: "%s...">' with '%s', replace '%s' with token_name and 20 self.contents elements with every newline deleted.

    def split_contents(self):
#ANNOTATION: define the method split_contents with an argument self.
        split = []
#ANNOTATION: split is an empty list.
        bits = iter(smart_split(self.contents))
#ANNOTATION: call the function smart_split with an argument self.contents, substitute the result converted to an iterable for bits.
        for bit in bits:
#ANNOTATION: for every bit in bits,
            # Handle translation-marked template pieces
            if bit.startswith('_("') or bit.startswith("_('"):
#ANNOTATION: if bit starts with '_("' ot bit starts with "_('",
                sentinal = bit[2] + ')'
#ANNOTATION: append ')' to third element of bit, substitute it for sentinal.
                trans_bit = [bit]
#ANNOTATION: trans_bit is a list with an element bit.
                while not bit.endswith(sentinal):
#ANNOTATION: while bit doesnt end with sential,
                    bit = next(bits)
#ANNOTATION: call the method next with an argument bits, substitute the result for bit. 
                    trans_bit.append(bit)
#ANNOTATION: append bit to trans_bit.
                bit = ' '.join(trans_bit)
#ANNOTATION: join trans_bit into a string separated with whitespaces, substitute the result for bit.
            split.append(bit)
#ANNOTATION: append bit to split.
        return split
#ANNOTATION: return split.


class Lexer(object):
#ANNOTATION: derive the class Lexer form the base class object.
    def __init__(self, template_string, origin):
#ANNOTATION: define the method __init__ with 3 arguments: self, template_string and origin.
        self.template_string = template_string
#ANNOTATION: substitute template_string for self.template_string.
        self.origin = origin
#ANNOTATION: substitute origin for self.origin.
        self.lineno = 1
#ANNOTATION: self.lineno is integer 1.
        self.verbatim = False
#ANNOTATION: self.verbatim is boolean False.

    def tokenize(self):
#ANNOTATION: define the method tokenize with an argument self.
        """
        Return a list of tokens from a given template_string.
        """
#ANNOTATION: docstring
        in_tag = False
#ANNOTATION: in_tag is boolean False.
        result = []
#ANNOTATION: result is an empty list.
        for bit in tag_re.split(self.template_string):
#ANNOTATION: split tag_re by self.template_string separator, for every bit in result,
            if bit:
#ANNOTATION: if bit is true,
                result.append(self.create_token(bit, in_tag))
#ANNOTATION: call the method self.create_token with 2 arguments bit and in_tag, append the result to result.
            in_tag = not in_tag
#ANNOTATION: in_tag is boolean True if in_tag is False, otherwise is boolean False.
        return result
#ANNOTATION: return result.

    def create_token(self, token_string, in_tag):
#ANNOTATION: define the method create_token with 3 arguments: self, token_string and in_tag.
        """
        Convert the given token string into a new Token object and return it.
        If in_tag is True, we are processing something that matched a tag,
        otherwise it should be treated as a literal string.
        """
#ANNOTATION: docstring
        if in_tag and token_string.startswith(BLOCK_TAG_START):
#ANNOTATION: if in_tag is true and token_string starts with BLOCK_TAG_START.
            # The [2:-2] ranges below strip off *_TAG_START and *_TAG_END.
            # We could do len(BLOCK_TAG_START) to be more "correct", but we've
            # hard-coded the 2s here for performance. And it's not like
            # the TAG_START values are going to change anytime, anyway.
            block_content = token_string[2:-2].strip()
#ANNOTATION: take elements of token_string from second to second last element and strip the whitespaces surrounding the result, 
#ANNOTATION: substitute the result for block_content. 
            if self.verbatim and block_content == self.verbatim:
#ANNOTATION: if self.verbatim is true and block_content equals self.verbatim,
                self.verbatim = False
#ANNOTATION: self.verbatim is boolean False.
        if in_tag and not self.verbatim:
#ANNOTATION: if in_tag and is not contained in self.verbatim,
            if token_string.startswith(VARIABLE_TAG_START):
#ANNOTATION: if token_string starts with VARIABLE_TAG_START,
                token = Token(TOKEN_VAR, token_string[2:-2].strip())
#ANNOTATION: token is an instance of Token class, created with 2 arguments: TOKEN_VAR,
#ANNOTATION: and elements of token_string from second to second last element wiht the whitespaces striped from the both sides.
            elif token_string.startswith(BLOCK_TAG_START):
#ANNOTATION: otherwise if token_string starts with BLOCK_TAG_START,
                if block_content[:9] in ('verbatim', 'verbatim '):
#ANNOTATION: if first nine elements of block_content is string 'verbatim' or 'verbatim ',
                    self.verbatim = 'end%s' % block_content
#ANNOTATION: append block_content to a string 'end', substitute the result for self.verbatim.
                token = Token(TOKEN_BLOCK, block_content)
#ANNOTATION: token is an instance of Token class, created with 2 arguments: TOKEN_BLOCK and block_content.
            elif token_string.startswith(COMMENT_TAG_START):
#ANNOTATION: otherwise if token_string starts with COMMENT_TAG_START,
                content = ''
#ANNOTATION: content is an empty string.
                if token_string.find(TRANSLATOR_COMMENT_MARK):
#ANNOTATION: call the method token_string.find with an argument TRANSLATOR_COMMENT_MARK, if it evaluates to true,
                    content = token_string[2:-2].strip()
#ANNOTATION: take elements of token_string from second to second last element and strip the whitespaces surrounding the result, 
#ANNOTATION: substitute the result for content. 
                token = Token(TOKEN_COMMENT, content)
#ANNOTATION: token is an instance of Token class, created with 2 arguments: TOKEN_COMMENT and content.
        else:
#ANNOTATION: if not,
            token = Token(TOKEN_TEXT, token_string)
#ANNOTATION: token is an instance of Token class, created with 2 arguments: TOKEN_TEXT and token_string.
        token.lineno = self.lineno
#ANNOTATION: substitute self.lineno for token.lineno.
        self.lineno += token_string.count('\n')
#ANNOTATION: call the method token_string.count with an argument '\n', append the result to self.lineno.
        return token
#ANNOTATION: return token.


class Parser(object):
#ANNOTATION: derive the class Parser form the base class object.
    def __init__(self, tokens):
#ANNOTATION: define the method __init__ with 2 arguments: self and token.
        self.tokens = tokens
#ANNOTATION: substitute tokens for self.tokens.
        self.tags = {}
#ANNOTATION: self.tags is an empty dictionary.
        self.filters = {}
#ANNOTATION: self.filters is an empty dictionary.
        for lib in builtins:
#ANNOTATION: for every lib in builtins,
            self.add_library(lib)
#ANNOTATION: call the method self.add_library with an argument lib. 

    def parse(self, parse_until=None):
#ANNOTATION: define the emethod parse with 2 arguments: self and parse_until set to None.
        if parse_until is None:
#ANNOTATION: if parse_until is None,
            parse_until = []
#ANNOTATION: parse_until is an empty list,
        nodelist = self.create_nodelist()
#ANNOTATION: call the method self.create_nodelist, substitute the result for nodelist.
        while self.tokens:
#ANNOTATION: while self.tokens is true,
            token = self.next_token()
#ANNOTATION: call the method self.next_token, substitute the result for token.
            # Use the raw values here for TOKEN_* for a tiny performance boost.
            if token.token_type == 0:  # TOKEN_TEXT
#ANNOTATION: if token.token_type equals integer 0,
                self.extend_nodelist(nodelist, TextNode(token.contents), token)
#ANNOTATION: call the method self.extend_nodelist with 3 arguments: nodelist, instance of TextNode class, created with an argument token.contents,
#ANNOTATION: and token.
            elif token.token_type == 1:  # TOKEN_VAR
#ANNOTATION: otherwise if token.token_type equals integer 1,
                if not token.contents:
#ANNOTATION: if token.contents is false,
                    self.empty_variable(token)
#ANNOTATION: call the method self.empty_variable with an argument token,
                try:
#ANNOTATION: try,
                    filter_expression = self.compile_filter(token.contents)
#ANNOTATION: call the method self.compile_filter with an argument token.contents, substitute the result for filter_expression.
                except TemplateSyntaxError as e:
#ANNOTATION: if TemplateSyntaxError, replaced with e, exception is caught,
                    if not self.compile_filter_error(token, e):
#ANNOTATION: call the method self.compile_filter_error with 2 arguments: token and e, if it evaluates to false,
                        raise
#ANNOTATION: raise an exception,
                var_node = self.create_variable_node(filter_expression)
#ANNOTATION: call the method self.create_variable_node with an argument filter_expression, substitute the result for var_node.
                self.extend_nodelist(nodelist, var_node, token)
#ANNOTATION: call the method self.extend_nodelist with 3 arguments: nodelist, var_node and token.
            elif token.token_type == 2:  # TOKEN_BLOCK
#ANNOTATION: otherwise if token.token_type equals integer 2,
                try:
#ANNOTATION: try,
                    command = token.contents.split()[0]
#ANNOTATION: split token.contents into separate words, substitute the first element of the result for command.
                except IndexError:
#ANNOTATION: if IndexError exception is caught,
                    self.empty_block_tag(token)
#ANNOTATION: call the method self.empty_block_tag with an argument token.
                if command in parse_until:
#ANNOTATION: if command is contained in parse_until,
                    # put token back on token list so calling
                    # code knows why it terminated
                    self.prepend_token(token)
#ANNOTATION: call the method self.prepend_token with an argument token,
                    return nodelist
#ANNOTATION: return nodelist.
                # execute callback function for this tag and append
                # resulting node
                self.enter_command(command, token)
#ANNOTATION: call the method self.enter_command with 2 arguments command and token.
                try:
#ANNOTATION: try,
                    compile_func = self.tags[command]
#ANNOTATION: substitute the value under the command key of self.tags dictionary for compile_func.
                except KeyError:
#ANNOTATION: if KeyError exception is caught,
                    self.invalid_block_tag(token, command, parse_until)
#ANNOTATION: call the method self.invalid_block_tag with 3 arguments: token, command and parse_until.
                try:
#ANNOTATION: try,
                    compiled_result = compile_func(self, token)
#ANNOTATION: call the method compile_func with 2 arguments self and token, substitute the result for compiled_result.
                except TemplateSyntaxError as e:
#ANNOTATION: if TemplateSyntaxError, renamed to e, exception is caught,
                    if not self.compile_function_error(token, e):
#ANNOTATION: call the method self.compile_function_error with 2 arguments token and e, if it evaluates to false,
                        raise
#ANNOTATION: raise an exception,
                self.extend_nodelist(nodelist, compiled_result, token)
#ANNOTATION: call the method self.extend_nodelist with 3 arguments: nodelist, compiled_result and token.
                self.exit_command()
#ANNOTATION: call the method self.exit_command.
        if parse_until:
#ANNOTATION: if parse_until is true,
            self.unclosed_block_tag(parse_until)
#ANNOTATION: call the method self.unclosed_block_tag with an argument parse_until.
        return nodelist
#ANNOTATION: return nodelist.

    def skip_past(self, endtag):
#ANNOTATION: define the method skip_past with 2 arguments: self and endtag.
        while self.tokens:
#ANNOTATION: while self.tokens is true,
            token = self.next_token()
#ANNOTATION: call the method self.next_token, substitute the result for token.
            if token.token_type == TOKEN_BLOCK and token.contents == endtag:
#ANNOTATION: if token.token_type equals TOKEN_BLOCK and token.contents equals endtag,
                return
#ANNOTATION: return nothing.
        self.unclosed_block_tag([endtag])
#ANNOTATION: call the method self.unclosed_block_tag with an argument list with an element endtag.

    def create_variable_node(self, filter_expression):
#ANNOTATION: define the method create_variable_node with 2 arguments self and filter_expression.
        return VariableNode(filter_expression)
#ANNOTATION: return an instance of VariableNode class with an argument filter_expression.

    def create_nodelist(self):
#ANNOTATION: define the method create_nodelist with an argument self.
        return NodeList()
#ANNOTATION: return an instance of NodeList class.

    def extend_nodelist(self, nodelist, node, token):
#ANNOTATION: define the method extend_nodelist with 4 arguments: self, nodelist, node and token.
        if node.must_be_first and nodelist:
#ANNOTATION: if node.must_be_first is true and nodelist is true,
            try:
#ANNOTATION: try,
                if nodelist.contains_nontext:
#ANNOTATION: if nodelist.contains_nontext is true,
                    raise AttributeError
#ANNOTATION: raise AttributeError exception,
            except AttributeError:
#ANNOTATION: if AttributeError exception is raised,
                raise TemplateSyntaxError("%r must be the first tag "
                                          "in the template." % node)
#ANNOTATION: raise TemplateSyntaxError("%r must be the first tag in the template.", where '%s' is replaced with node.
        if isinstance(nodelist, NodeList) and not isinstance(node, TextNode):
#ANNOTATION: if nodelist is an instance of NodeList and node is not an instance of TextNode class.
            nodelist.contains_nontext = True
#ANNOTATION: nodelist.contains_nontext is boolean True.
        nodelist.append(node)
#ANNOTATION: append node to nodelist.

    def enter_command(self, command, token):
#ANNOTATION: define the method enter_command with 3 arguments: self, command and token.
        pass
#ANNOTATION: do nothing.

    def exit_command(self):
#ANNOTATION: define the method exit_command with an argument self.
        pass
#ANNOTATION: do nothing.

    def error(self, token, msg):
#ANNOTATION: define the method enter_command with 3 arguments: self, token and msg.
        return TemplateSyntaxError(msg)
#ANNOTATION: return an instance of TemplateSyntaxError class with an argument msg.

    def empty_variable(self, token):
#ANNOTATION: define the method empty_variable with 2 arguments: self and token.
        raise self.error(token, "Empty variable tag")
#ANNOTATION: call the method self.error with 2 arguments: token and string "Empty variable tag", return the result.

    def empty_block_tag(self, token):
#ANNOTATION: define the method empty_block_tag with 2 arguments: self and token.
        raise self.error(token, "Empty block tag")
#ANNOTATION: call the method self.error with 2 arguments: token and string "Empty block tag", return the result.

    def invalid_block_tag(self, token, command, parse_until=None):
#ANNOTATION: define the method invalid_block_tag with 4 arguments: self, token, command and parse_until as None.
        if parse_until:
#ANNOTATION: if parse_until is true,
            raise self.error(token, "Invalid block tag: '%s', expected %s" %
                (command, get_text_list(["'%s'" % p for p in parse_until])))
#ANNOTATION: raise an self.error exception with 2 arguments: token and string  "Invalid block tag: '%s', expected %s", 
#ANNOTATION: where '%s' is replaced with command and result of the function get_text_list called with an argument list,
#ANNOTATION: with p converted into a string and surrounded with single quotes for every p in parse_until.
        raise self.error(token, "Invalid block tag: '%s'" % command)
#ANNOTATION: call the method self.error with 2 arguments: token and string "Invalid block tag: '%s'", where '%s' is replaced with command,
#ANNOTATION: return the result.

    def unclosed_block_tag(self, parse_until):
#ANNOTATION: define the method unclosed_block_tag with 2 arguments: self and parse_until.
        raise self.error(None, "Unclosed tags: %s " % ', '.join(parse_until))
#ANNOTATION: raise an self.error with 2 arguments: None and string "Unclosed tags: %s ", 
#ANNOTATION: where '%s' is replaced with parse_until elements joined into a string, separated with ', '.

    def compile_filter_error(self, token, e):
#ANNOTATION: define the method compile_filter_error with 3 arguments: self, token and e.
        pass
#ANNOTATION: do nothing.

    def compile_function_error(self, token, e):
#ANNOTATION: define the method compile_function_error with 3 arguments: self, token and e.
        pass
#ANNOTATION: do nothing.

    def next_token(self):
#ANNOTATION: define the method next_token with an argument self.
        return self.tokens.pop(0)
#ANNOTATION: remove first element from self.tokens, return removed element.

    def prepend_token(self, token):
#ANNOTATION: define the function prepend_token with 2 arguments: self and token.
        self.tokens.insert(0, token)
#ANNOTATION: insert token at the beginning of self.tokens.

    def delete_first_token(self):
#ANNOTATION: define the method delete_first_token with an argument self.
        del self.tokens[0]
#ANNOTATION: delete the first element of self.tokens.

    def add_library(self, lib):
#ANNOTATION: define the function add_library with 2 arguments: self and lib.
        self.tags.update(lib.tags)
#ANNOTATION: update self.tags dictionary with lib.tags.
        self.filters.update(lib.filters)
#ANNOTATION: update self.filters dictionary with lib.filters.

    def compile_filter(self, token):
#ANNOTATION: define the function compile_filter with 2 arguments: self and token.
        """
        Convenient wrapper for FilterExpression
        """
#ANNOTATION: docstring
        return FilterExpression(token, self)
#ANNOTATION: return an instance of FilterExpression class, created with 2 arguments: token and self.

    def find_filter(self, filter_name):
#ANNOTATION: define the function find_filter with 2 arguments: self and filter_name.
        if filter_name in self.filters:
#ANNOTATION: if filter_name is contained in self.filters,
            return self.filters[filter_name]
#ANNOTATION: return the value under the filter_name key of the self.filters dictionary.
        else:
#ANNOTATION: if not,
            raise TemplateSyntaxError("Invalid filter: '%s'" % filter_name)
#ANNOTATION: raise an TemplateSyntaxError with an argument string "Invalid filter: '%s'", substitute '%s' with filter_name.


class TokenParser(object):
#ANNOTATION: derive the class TokenParser form the base class object.
    """
    Subclass this and implement the top() method to parse a template line.
    When instantiating the parser, pass in the line from the Django template
    parser.

    The parser's "tagname" instance-variable stores the name of the tag that
    the filter was called with.
    """
#ANNOTATION: docstring
    def __init__(self, subject):
#ANNOTATION: define the function next_space_index with 2 arguments: self and subject.
        self.subject = subject
#ANNOTATION: substitute subject for self.subject.
        self.pointer = 0
#ANNOTATION: self.pointer is integer 0.
        self.backout = []
#ANNOTATION: self.backout is an empty list.
        self.tagname = self.tag()
#ANNOTATION: call the method self.tag, substitute the result for self.tagname.

    def top(self):
#ANNOTATION: define the method top with an argument self.
        """
        Overload this method to do the actual parsing and return the result.
        """
#ANNOTATION: docstring
        raise NotImplementedError('subclasses of Tokenparser must provide a top() method')
#ANNOTATION: raise an NotImplementedError with an argument string 'subclasses of Tokenparser must provide a top() method'.

    def more(self):
#ANNOTATION: define the method more with an argument self.
        """
        Returns True if there is more stuff in the tag.
        """
#ANNOTATION: docstring
        return self.pointer < len(self.subject)
#ANNOTATION: if self.pointer is smaller than length of self.subject, return boolean True, otherwise return False.

    def back(self):
#ANNOTATION: define the method back with an argument self.
        """
        Undoes the last microparser. Use this for lookahead and backtracking.
        """
#ANNOTATION: docstring
        if not len(self.backout):
#ANNOTATION: if length of self.backout is greater than zero,
            raise TemplateSyntaxError("back called without some previous "
                                      "parsing")
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "back called without some previous parsing".
        self.pointer = self.backout.pop()
#ANNOTATION: remove the first element from self.backout, substitute the result for self.pointer.

    def tag(self):
#ANNOTATION: define the method tag with an argument self.
        """
        A microparser that just returns the next tag from the line.
        """
#ANNOTATION: docstring
        subject = self.subject
#ANNOTATION: substitute self.subject for subject.
        i = self.pointer
#ANNOTATION: substitute self.pointer for i.
        if i >= len(subject):
#ANNOTATION: if i is greater than or equal to length of subject.
            raise TemplateSyntaxError("expected another tag, found "
                                      "end of string: %s" % subject)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "expected another tag, found end of string: %s",
#ANNOTATION: where '%s' is replaced with subject.
        p = i
#ANNOTATION: substitute i for p.
        while i < len(subject) and subject[i] not in (' ', '\t'):
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is not an empty space or tab character,
            i += 1
#ANNOTATION: increment i by integer 1.
        s = subject[p:i]
#ANNOTATION: take subject elements from p-th to i-th index, substitute it for s.
        while i < len(subject) and subject[i] in (' ', '\t'):
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is an empty space or tab character,
            i += 1
#ANNOTATION: increment i by integer 1.
        self.backout.append(self.pointer)
#ANNOTATION: append self.pointer to self.backout.
        self.pointer = i
#ANNOTATION: substitute i for self.pointer.
        return s
#ANNOTATION: return s.

    def value(self):
#ANNOTATION: define the method value with an argument self.
        """
        A microparser that parses for a value: some string constant or
        variable name.
        """
#ANNOTATION: docstring
        subject = self.subject
#ANNOTATION: substitute self.subject for subject.
        i = self.pointer
#ANNOTATION: substitute self.pointer for i.

        def next_space_index(subject, i):
#ANNOTATION: define the next_space_index with 2 arguments: subject and i.
            """
            Increment pointer until a real space (i.e. a space not within
            quotes) is encountered
            """
#ANNOTATION: docstring
            while i < len(subject) and subject[i] not in (' ', '\t'):
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is not an empty space or tab character,
                if subject[i] in ('"', "'"):
#ANNOTATION: if i-th element of subject is '"' character or "'" character,
                    c = subject[i]
#ANNOTATION: substitute i-th element of subject for c.
                    i += 1
#ANNOTATION: increment i by integer 1.
                    while i < len(subject) and subject[i] != c:
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is not equal to c,
                        i += 1
#ANNOTATION: increment i by one.
                    if i >= len(subject):
#ANNOTATION: if i is greater than, or equal to subject,
                        raise TemplateSyntaxError("Searching for value. "
                            "Unexpected end of string in column %d: %s" %
                            (i, subject))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Searching for value. Unexpected end of string in column %d: %s",
#ANNOTATION: where '%d' is replaced with i and '%s' is replaced with subject.
                i += 1
#ANNOTATION: increment i by one.
            return i
#ANNOTATION: return i.

        if i >= len(subject):
#ANNOTATION: if i is greater than or equal to length of subject,
            raise TemplateSyntaxError("Searching for value. Expected another "
                                      "value but found end of string: %s" %
                                      subject)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument "Searching for value. Expected another value but found end of string: %s",
#ANNOTATION: where '%s' is replaced with subject.
        if subject[i] in ('"', "'"):
#ANNOTATION: if i-th element of subject is '"' character or "'" character,
            p = i
#ANNOTATION: substitute i for p.
            i += 1
#ANNOTATION: increment i by integer 1,
            while i < len(subject) and subject[i] != subject[p]:
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is not equal to p-th element of subject,
                i += 1
#ANNOTATION: increment i by integer 1,
            if i >= len(subject):
#ANNOTATION: if i is greater than length of subject,
                raise TemplateSyntaxError("Searching for value. Unexpected "
                                          "end of string in column %d: %s" %
                                          (i, subject))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Searching for value. Unexpected end of string in column %d: %s",
#ANNOTATION: where '%d' is replaced with i and '%s' is replaced with subject.
            i += 1
#ANNOTATION: increment i by integer 1,

            # Continue parsing until next "real" space,
            # so that filters are also included
            i = next_space_index(subject, i)
#ANNOTATION: call the function next_space_index with 2 arguments: subject and i, substitute the result for i.

            res = subject[p:i]
#ANNOTATION: substitute subject elements from p-th to i-th index for res.
            while i < len(subject) and subject[i] in (' ', '\t'):
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is an empty space or tab character.
                i += 1
#ANNOTATION: increment i by integer 1,
            self.backout.append(self.pointer)
#ANNOTATION: append self.pointer to self.backout.
            self.pointer = i
#ANNOTATION: substitute i for self.pointer.
            return res
#ANNOTATION: return res.
        else:
#ANNOTATION: if not,
            p = i
#ANNOTATION: substitute i for p.
            i = next_space_index(subject, i)
#ANNOTATION: call the function next_space_index with 2 arguments subject and i, substitute the result for i.
            s = subject[p:i]
#ANNOTATION: take subject elements from p-th to i-th index, substitute it for s.
            while i < len(subject) and subject[i] in (' ', '\t'):
#ANNOTATION: while i is lesser than length of subject and i-th element of subject is an empty space or tab character.
                i += 1
#ANNOTATION: increment i by integer 1,.
            self.backout.append(self.pointer)
#ANNOTATION: append self.pointer to self.backout.
            self.pointer = i
#ANNOTATION: substitute i for self.pointer.
            return s
#ANNOTATION: return s.

# This only matches constant *strings* (things in quotes or marked for
# translation). Numbers are treated as variables for implementation reasons
# (so that they retain their type when passed to filters).
constant_string = r"""
(?:%(i18n_open)s%(strdq)s%(i18n_close)s|
%(i18n_open)s%(strsq)s%(i18n_close)s|
%(strdq)s|
%(strsq)s)
""" % {
    'strdq': r'"[^"\\]*(?:\\.[^"\\]*)*"',  # double-quoted string
    'strsq': r"'[^'\\]*(?:\\.[^'\\]*)*'",  # single-quoted string
    'i18n_open': re.escape("_("),
    'i18n_close': re.escape(")"),
}
#ANNOTATION: constant_string is a raw string "(?:%(i18n_open)s%(strdq)s%(i18n_close)s|%(i18n_open)s%(strsq)s%(i18n_close)s|%(strdq)s|%(strsq)s)",
#ANNOTATION: where 'strdq' is replaced with '"[^"\\]*(?:\\.[^"\\]*)*"', 'strsq' is replaced with "'[^'\\]*(?:\\.[^'\\]*)*'", 
#ANNOTATION: 'i18n_open' is replaced with return value of function re.escape called with an argument string '_(',
#ANNOTATION: 'i18n_close' is replaced with return value of function re.escape called with an argument string ')'.
constant_string = constant_string.replace("\n", "")
#ANNOTATION: remove all occurrences of newline character from constant_string.

filter_raw_string = r"""
^(?P<constant>%(constant)s)|
^(?P<var>[%(var_chars)s]+|%(num)s)|
 (?:\s*%(filter_sep)s\s*
     (?P<filter_name>\w+)
         (?:%(arg_sep)s
             (?:
              (?P<constant_arg>%(constant)s)|
              (?P<var_arg>[%(var_chars)s]+|%(num)s)
             )
         )?
 )""" % {
    'constant': constant_string,
    'num': r'[-+\.]?\d[\d\.e]*',
    'var_chars': "\w\.",
    'filter_sep': re.escape(FILTER_SEPARATOR),
    'arg_sep': re.escape(FILTER_ARGUMENT_SEPARATOR),
}
#ANNOTATION: filter_raw_string is a raw string "^(?P<constant>%(constant)s)|^(?P<var>[%(var_chars)s]+|%(num)s)| (?:\s*%(filter_sep)s\s*
#ANNOTATION: (?P<filter_name>\w+)(?:%(arg_sep)s(?:(?P<constant_arg>%(constant)s)|(?P<var_arg>[%(var_chars)s]+|%(num)s)))?)",
#ANNOTATION: where 'constant' is replaced with constant_string, 'num' with raw string '[-+\.]?\d[\d\.e]*', 'var_chars' with string "\w\.",
#ANNOTATION: 'filter_sep' with result of the function re.escape called with an argument FILTER_SEPARATOR, 
#ANNOTATION: anbd 'arg_sep' with result of the function re.escape called with an argument FILTER_ARGUMENT_SEPARATOR.

filter_re = re.compile(filter_raw_string, re.UNICODE | re.VERBOSE)
#ANNOTATION: call the function re.compile with 2 arguments: filter_raw_string and result for bitwise OR on 2 operands re.UNICODE and re.VERBOSE,
#ANNOTATION: substitute the result for filter_re.


class FilterExpression(object):
#ANNOTATION: derive the class FilterExpression form the base class object.
    """
    Parses a variable token and its optional filters (all as a single string),
    and return a list of tuples of the filter name and arguments.
    Sample::

        >>> token = 'variable|default:"Default value"|date:"Y-m-d"'
        >>> p = Parser('')
        >>> fe = FilterExpression(token, p)
        >>> len(fe.filters)
        2
        >>> fe.var
        <Variable: 'variable'>
    """
#ANNOTATION: docstring
    def __init__(self, token, parser):
#ANNOTATION: define the function __init__ with 3 arguments: self, token and parser.
        self.token = token
#ANNOTATION: substitute token for self.token.
        matches = filter_re.finditer(token)
#ANNOTATION: call the method filter_re.finditer with an argument token, substitute the result for matches.
        var_obj = None
#ANNOTATION: var_obj is None.
        filters = []
#ANNOTATION: filters is an empty list.
        upto = 0
#ANNOTATION: upto is integer 0.
        for match in matches:
#ANNOTATION: for every match in matches,
            start = match.start()
#ANNOTATION: call the method match.start, substitute the result for start.
            if upto != start:
#ANNOTATION: if upto is not equal to start.
                raise TemplateSyntaxError("Could not parse some characters: "
                                          "%s|%s|%s" %
                                          (token[:upto], token[upto:start],
                                           token[start:]))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Could not parse some characters: %s|%s|%s",
#ANNOTATION: where '%s' is replaced with first upto elements of token string, token string elements from upto to start index,
#ANNOTATION: and token string elements from start index to the end.
            if var_obj is None:
#ANNOTATION: if var_obj is None,
                var, constant = match.group("var", "constant")
#ANNOTATION: call the method match.group with 2 arguments: strings "var" and "constant", substitute the result for var and constant, respectively.
                if constant:
#ANNOTATION: if constant is true,
                    try:
#ANNOTATION: try,
                        var_obj = Variable(constant).resolve({})
#ANNOTATION: instantiate Variable class, with an argument constant, call the resolve method with an empty dictionary as an argument, substitute the result for var_obj.
                    except VariableDoesNotExist:
#ANNOTATION: if VariableDoesNotExist exception is not caught,
                        var_obj = None
#ANNOTATION: var_obj is None.
                elif var is None:
#ANNOTATION: otherwise if var is None,
                    raise TemplateSyntaxError("Could not find variable at "
                                              "start of %s." % token)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument "Could not find variable at start of %s.", replace '%s' with token.
                else:
#ANNOTATION: if not, 
                    var_obj = Variable(var)
#ANNOTATION: var_obj is an instance of Variable class, created with an argument var.
            else:
#ANNOTATION: if not,
                filter_name = match.group("filter_name")
#ANNOTATION: call the methof match.group with an argument "filter_name", substitute the result for filter_name.
                args = []
#ANNOTATION: args is an empty list.
                constant_arg, var_arg = match.group("constant_arg", "var_arg")
#ANNOTATION: call the method match.group with 2 arguments: strings "constant_arg" and "var_arg", substitute the result for constant_arg,
#ANNOTATION: and var_arg, respectively.
                if constant_arg:
#ANNOTATION: if constant_arg is true,
                    args.append((False, Variable(constant_arg).resolve({})))
#ANNOTATION: take a tuple with 2 elements: boolean False and method resolve called with an empty dictionary on the instance of Variable class,
#ANNOTATION: created with an argument constant_arg, append it to args.
                elif var_arg:
#ANNOTATION: otherwise if var_arg is true,
                    args.append((True, Variable(var_arg)))
#ANNOTATION: take a tuple with 2 elements: boolean False and instance of Variable class, created with an argument constant_arg, append it to args.
                filter_func = parser.find_filter(filter_name)
#ANNOTATION: call the method parser.find_filter with an argument filter_name, substitute the result for filter_func.
                self.args_check(filter_name, filter_func, args)
#ANNOTATION: call the method self.args_check with 3 arguments: filter_name, filter_func and args.
                filters.append((filter_func, args))
#ANNOTATION: append a tuple with 2 arguments: filter_func and args to filters.
            upto = match.end()
#ANNOTATION: call the method match.end, substitute the result for upto.
        if upto != len(token):
#ANNOTATION: if upto is not equal to length of token,
            raise TemplateSyntaxError("Could not parse the remainder: '%s' "
                                      "from '%s'" % (token[upto:], token))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Could not parse the remainder: '%s' from '%s'",
#ANNOTATION: where '%s' is replaced with elemnts of token from upto index till the end, and token.

        self.filters = filters
#ANNOTATION: substitute filters for self.filters.
        self.var = var_obj
#ANNOTATION: substitute var_obj for self.var.

    def resolve(self, context, ignore_failures=False):
#ANNOTATION: define the method resolve with 3 arguments: self, context and ignore_failures set to boolean False.
        if isinstance(self.var, Variable):
#ANNOTATION: if self.var is an instance of Variable class,
            try:
#ANNOTATION: try,
                obj = self.var.resolve(context)
#ANNOTATION: call the method self.var.resolve with an argument context, substitute it for obj.
            except VariableDoesNotExist:
#ANNOTATION: if VariableDoesNotExist exception is caught,
                if ignore_failures:
#ANNOTATION: if ignore_failures is true,
                    obj = None
#ANNOTATION: obj is None,
                else:
#ANNOTATION: if not,
                    if settings.TEMPLATE_STRING_IF_INVALID:
#ANNOTATION: if settings.TEMPLATE_STRING_IF_INVALID is true,
                        global invalid_var_format_string
#ANNOTATION: use global variable invalid_var_format_string.
                        if invalid_var_format_string is None:
#ANNOTATION: if invalid_var_format_string is None,
                            invalid_var_format_string = '%s' in settings.TEMPLATE_STRING_IF_INVALID
#ANNOTATION: if '%s' is contained in settings.TEMPLATE_STRING_IF_INVALID, invalid_var_format_string is boolean True, otherwise it is False.
                        if invalid_var_format_string:
#ANNOTATION: if invalid_var_format_string is true,
                            return settings.TEMPLATE_STRING_IF_INVALID % self.var
#ANNOTATION: format settings.TEMPLATE_STRING_IF_INVALID with self.var, return the result.
                        return settings.TEMPLATE_STRING_IF_INVALID
#ANNOTATION: return settings.TEMPLATE_STRING_IF_INVALID.
                    else:
#ANNOTATION: if not,
                        obj = settings.TEMPLATE_STRING_IF_INVALID
#ANNOTATION: substitute settings.TEMPLATE_STRING_IF_INVALID with obj.
        else:
#ANNOTATION: if not,
            obj = self.var
#ANNOTATION: substitute self.var for obj.
        for func, args in self.filters:
#ANNOTATION: for every func and args in self.filters,
            arg_vals = []
#ANNOTATION: arg_vals is an empty list,
            for lookup, arg in args:
#ANNOTATION: for every lookup and arg in args,
                if not lookup:
#ANNOTATION: if lookup is false,
                    arg_vals.append(mark_safe(arg))
#ANNOTATION: call the function mark_safe with an argument arg, append it to arg_vals.
                else:
#ANNOTATION: if not,
                    arg_vals.append(arg.resolve(context))
#ANNOTATION: call the method arg.resolve with an argument context, append the result to arg_vals.
            if getattr(func, 'expects_localtime', False):
#ANNOTATION: if 'expects_localtime' attribute of func object exists and is true,
                obj = template_localtime(obj, context.use_tz)
#ANNOTATION: call the function template_localtime with 2 arguments: obj and context.use_tz, substitute the result for obj.
            if getattr(func, 'needs_autoescape', False):
#ANNOTATION: if 'needs_autoescape' attribute of func object exists and is true,
                new_obj = func(obj, autoescape=context.autoescape, *arg_vals)
#ANNOTATION: call the function func with 3 arguments: obj, autoescape set to context.autoescape and unpacked list arg_vals, 
#ANNOTATION: substitute the result for new_obj.
            else:
#ANNOTATION: if not,
                new_obj = func(obj, *arg_vals)
#ANNOTATION: call the function func with 2 arguments: obj and unpacked list arg_vals, substitute the result for new_obj.
            if getattr(func, 'is_safe', False) and isinstance(obj, SafeData):
#ANNOTATION: if 'is_safe' attribute of func object exists and is true and obj is an instance of SafeData,
                obj = mark_safe(new_obj)
#ANNOTATION: call the function mark_safe with an argument new_obj, substitute the result for obj.
            elif isinstance(obj, EscapeData):
#ANNOTATION: otherwise if obj is an instance of EscapeData,
                obj = mark_for_escaping(new_obj)
#ANNOTATION: call the function mark_for_escaping with an argument new_obj, substitute the result for obj.
            else:
#ANNOTATION: if not,
                obj = new_obj
#ANNOTATION: substitute new_obj for obj.
        return obj
#ANNOTATION: return obj.

    def args_check(name, func, provided):
#ANNOTATION: define the method args_check with 3 arguments: name, func and provided.
        provided = list(provided)
#ANNOTATION: convert provided into a list and substitute it for provided.
        # First argument, filter input, is implied.
        plen = len(provided) + 1
#ANNOTATION: calculate length of provided and increment it by one, substitute the result for plen.
        # Check to see if a decorator is providing the real function.
        func = getattr(func, '_decorated_function', func)
#ANNOTATION: get the '_decorated_function' attribute from func object, if it exists substitute it for func.
        args, varargs, varkw, defaults = getargspec(func)
#ANNOTATION: call the function getargspec with an argument func, substitute the result for args, varargs, varkw and defaults, respectively.
        alen = len(args)
#ANNOTATION: calculate the length of args, substitute it for alen.
        dlen = len(defaults or [])
#ANNOTATION: substitute the length of defaults for dlen.
        # Not enough OR Too many
        if plen < (alen - dlen) or plen > alen:
#ANNOTATION: if plen is lesser than difference of alen and dlen, or if plen is greater than alen,
            raise TemplateSyntaxError("%s requires %d arguments, %d provided" %
                                      (name, alen - dlen, plen))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "%s requires %d arguments, %d provided",
#ANNOTATION: where '%d' is replaced with name, dlen subtracted from alen, and plen.

        return True
#ANNOTATION: return boolean True.
    args_check = staticmethod(args_check)
#ANNOTATION: args_check is a static method.

    def __str__(self):
#ANNOTATION: define the method __str__ with an argument self.
        return self.token
#ANNOTATION: return self.token.


def resolve_variable(path, context):
#ANNOTATION: define the method resolve_variable with 2 arguments: path and context.
    """
    Returns the resolved variable, which may contain attribute syntax, within
    the given context.

    Deprecated; use the Variable class instead.
    """
#ANNOTATION: docstring
    warnings.warn("resolve_variable() is deprecated. Use django.template."
                  "Variable(path).resolve(context) instead",
                  RemovedInDjango20Warning, stacklevel=2)
#ANNOTATION: call the function warnings.warn with 3 arguments: 
#ANNOTATION: string "resolve_variable() is deprecated. Use django.template. Variable(path).resolve(context) instead", RemovedInDjango20Warning,
#ANNOTATION: and stacklevel set to integer 2.
    return Variable(path).resolve(context)
#ANNOTATION: call the method resolve with an argument context, from the instance of Variable class, created with an argument path.


class Variable(object):
#ANNOTATION: derive the class Variable form the base class object.
    """
    A template variable, resolvable against a given context. The variable may
    be a hard-coded string (if it begins and ends with single or double quote
    marks)::

        >>> c = {'article': {'section':u'News'}}
        >>> Variable('article.section').resolve(c)
        u'News'
        >>> Variable('article').resolve(c)
        {'section': u'News'}
        >>> class AClass: pass
        >>> c = AClass()
        >>> c.article = AClass()
        >>> c.article.section = u'News'

    (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')
    """
#ANNOTATION: docstring

    def __init__(self, var):
#ANNOTATION: define the method __init__ with 2 arguments self and var. 
        self.var = var
#ANNOTATION: substitute var for self.var.
        self.literal = None
#ANNOTATION: self.literal is None,
        self.lookups = None
#ANNOTATION: self.lookups is None.
        self.translate = False
#ANNOTATION: self.translate is boolean False.
        self.message_context = None
#ANNOTATION: self.message_context is None.

        if not isinstance(var, six.string_types):
#ANNOTATION: if var is not an instance of six.string_types,
            raise TypeError(
                "Variable must be a string or number, got %s" % type(var))
#ANNOTATION: raise an TypeError exception with an argument string "Variable must be a string or number, got %s", replace '%s' with type of var.
        try:
#ANNOTATION: try,
            # First try to treat this variable as a number.
            #
            # Note that this could cause an OverflowError here that we're not
            # catching. Since this should only happen at compile time, that's
            # probably OK.
            self.literal = float(var)
#ANNOTATION: convert var into an floating point number, substitute it for self.literal.

            # So it's a float... is it an int? If the original value contained a
            # dot or an "e" then it was a float, not an int.
            if '.' not in var and 'e' not in var.lower():
#ANNOTATION: if '.' is not contained in var and 'e' is not contained in var converted into lowercase,
                self.literal = int(self.literal)
#ANNOTATION: convert self.literal into an integer, substitute it for self.literal.

            # "2." is invalid
            if var.endswith('.'):
#ANNOTATION: if var ends with '.',
                raise ValueError
#ANNOTATION: raise an ValueError exception.

        except ValueError:
#ANNOTATION: if ValueError exception is caught,
            # A ValueError means that the variable isn't a number.
            if var.startswith('_(') and var.endswith(')'):
#ANNOTATION: if var starts with '_(' and var ends with ')',
                # The result of the lookup should be translated at rendering
                # time.
                self.translate = True
#ANNOTATION: self.translate is boolean True.
                var = var[2:-1]
#ANNOTATION: remove first 2 and last 2 elements from var.
            # If it's wrapped with quotes (single or double), then
            # we're also dealing with a literal.
            try:
#ANNOTATION: try,
                self.literal = mark_safe(unescape_string_literal(var))
#ANNOTATION: call the function unescape_string_literal with an argument var, use it as an argument for the call to the function mark_safe, 
#ANNOTATION: substitute the result for self.literal.
            except ValueError:
#ANNOTATION: if ValueError exception is caught,
                # Otherwise we'll set self.lookups so that resolve() knows we're
                # dealing with a bonafide variable
                if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':
#ANNOTATION: call the function var.find with an argument: '_' appended to VARIABLE_ATTRIBUTE_SEPARATOR, if the result is greater than integer -1,
#ANNOTATION: or first element of var equals '_',
                    raise TemplateSyntaxError("Variables and attributes may "
                                              "not begin with underscores: '%s'" %
                                              var)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Variables and attributes may not begin with underscores: '%s'",
#ANNOTATION: where '%s' is replaced with var.
                self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))
#ANNOTATION: call the method var.split with an argument VARIABLE_ATTRIBUTE_SEPARATOR, convert the result to a tuple and substitute it for self.lookups.

    def resolve(self, context):
#ANNOTATION: define the method resolve with 2 arguments: self and context.
        """Resolve this variable against a given context."""
#ANNOTATION: docstring
        if self.lookups is not None:
#ANNOTATION: if self.lookups is not None,
            # We're dealing with a variable that needs to be resolved
            value = self._resolve_lookup(context)
#ANNOTATION: call the function self._resolve_lookup with an argument context, substitute the result for value.
        else:
#ANNOTATION: if else,
            # We're dealing with a literal, so it's already been "resolved"
            value = self.literal
#ANNOTATION: substitute self.literal for value.
        if self.translate:
#ANNOTATION: if self.translate is true,
            if self.message_context:
#ANNOTATION: if self.message_context is true,
                return pgettext_lazy(self.message_context, value)
#ANNOTATION: call the function pgettext_lazy with an argument self.message_context and value, return the result.
            else:
#ANNOTATION: if not,
                return ugettext_lazy(value)
#ANNOTATION: call the function ugettext_lazy with an argument value, return the result.
        return value
#ANNOTATION: return value.

    def __repr__(self):
#ANNOTATION: define the method __repr__ with an argument self.
        return "<%s: %r>" % (self.__class__.__name__, self.var)
#ANNOTATION: return an string "<%s: %r>", where '%s' is replaced with self.__class__.__name__ and self.var, respectively.

    def __str__(self):
#ANNOTATION: define the method __str__ with an argument self.
        return self.var
#ANNOTATION: return self.var.

    def _resolve_lookup(self, context):
#ANNOTATION: define the method _resolve_lookup with 2 arguments: self and context.
        """
        Performs resolution of a real variable (i.e. not a literal) against the
        given context.

        As indicated by the method's name, this method is an implementation
        detail and shouldn't be called by external code. Use Variable.resolve()
        instead.
        """
#ANNOTATION: docstring
        current = context
#ANNOTATION: substitute context for current.
        try:  # catch-all for silent variable failures
#ANNOTATION: try,
            for bit in self.lookups:
#ANNOTATION: for bit in self.lookups,
                try:  # dictionary lookup
#ANNOTATION: try,
                    current = current[bit]
#ANNOTATION: substitute element at the bit index of current for current.
                except (TypeError, AttributeError, KeyError, ValueError):
#ANNOTATION: if TypeError, AttributeError, KeyError or ValueError exceptions are caught,
                    try:  # attribute lookup
#ANNOTATION: try,
                        # Don't return class attributes if the class is the context:
                        if isinstance(current, BaseContext) and getattr(type(current), bit):
#ANNOTATION: if current is an instance of BaseContext and bit attribute of type of current is true,
                            raise AttributeError
#ANNOTATION: raise an AttributeError exception.
                        current = getattr(current, bit)
#ANNOTATION: get the bit attribute of current object, substitute it for current.
                    except (TypeError, AttributeError):
#ANNOTATION: if TypeError and AttributeError exceptions are caught,
                        try:  # list-index lookup
#ANNOTATION: try,
                            current = current[int(bit)]
#ANNOTATION: convert bit to an integer and use it as index to obtain an element for list current, substitute it for current.
                        except (IndexError,  # list index out of range
                                ValueError,  # invalid literal for int()
                                KeyError,    # current is a dict without `int(bit)` key
                                TypeError):  # unsubscriptable object
#ANNOTATION: if IndexError, ValueError, KeyError or TypeError exceptions are caught,
                            raise VariableDoesNotExist("Failed lookup for key "
                                                       "[%s] in %r",
                                                       (bit, current))  # missing attribute
#ANNOTATION: raise an VariableDoesNotExist exception with an argument string "Failed lookup for key [%s] in %r", 
#ANNOTATION: where '%s' is replaced with bit and '%r' is replaced with current.
                if callable(current):
#ANNOTATION: if current is callable object,
                    if getattr(current, 'do_not_call_in_templates', False):
#ANNOTATION: get the 'do_not_call_in_templates' attribute of current object, if it exists and is true,
                        pass
#ANNOTATION: do nothing.
                    elif getattr(current, 'alters_data', False):
#ANNOTATION: otherwise, get the 'alters_data' attribute of current object, if it exists and is true,
                        current = settings.TEMPLATE_STRING_IF_INVALID
#ANNOTATION: substitute settings.TEMPLATE_STRING_IF_INVALID for current.
                    else:
#ANNOTATION: if not,
                        try:  # method call (assuming no args required)
#ANNOTATION: try,
                            current = current()
#ANNOTATION: call the function current, substitute the result for current.
                        except TypeError:
#ANNOTATION: if TypeError exception is caught,
                            try:
#ANNOTATION: try,
                                getcallargs(current)
#ANNOTATION: call the function getcallargs with an argument current,
                            except TypeError:  # arguments *were* required
#ANNOTATION: if TypeError exception is caught,
                                current = settings.TEMPLATE_STRING_IF_INVALID  # invalid method call
#ANNOTATION: substitute settings.TEMPLATE_STRING_IF_INVALID for current,
                            else:
#ANNOTATION: if not,
                                raise
#ANNOTATION: raise an exception,
        except Exception as e:
#ANNOTATION: if Exception, renamed to e, exception is caught,
            if getattr(e, 'silent_variable_failure', False):
#ANNOTATION: get the 'silent_variable_failure' attribute of e object, if it exists and is true,
                current = settings.TEMPLATE_STRING_IF_INVALID
#ANNOTATION: substitute settings.TEMPLATE_STRING_IF_INVALID for current.
            else:
#ANNOTATION: if not,
                raise
#ANNOTATION: raise an exception.

        return current
#ANNOTATION: return current.


class Node(object):
#ANNOTATION: derive the class Node form the base class object.
    # Set this to True for nodes that must be first in the template (although
    # they can be preceded by text nodes.
    must_be_first = False
#ANNOTATION: must_be_first is boolean False.
    child_nodelists = ('nodelist',)
#ANNOTATION: child_nodelists is an tuple with an element 'nodelist'.

    def render(self, context):
#ANNOTATION: define the method render with 2 arguments: self and context.
        """
        Return the node rendered as a string.
        """
#ANNOTATION: docstring
        pass
#ANNOTATION: do nothing.

    def __iter__(self):
#ANNOTATION: define the method __iter__ with an argument self.
        yield self
#ANNOTATION: yield self.

    def get_nodes_by_type(self, nodetype):
#ANNOTATION: define the method get_nodes_by_type with 2 arguments: self and nodetype.
        """
        Return a list of all nodes (within this node and its nodelist)
        of the given type
        """
#ANNOTATION: docstring
        nodes = []
#ANNOTATION: nodes is an empty list.
        if isinstance(self, nodetype):
#ANNOTATION: if self is an instance of nodetype,
            nodes.append(self)
#ANNOTATION: append self to nodes.
        for attr in self.child_nodelists:
#ANNOTATION: for every attr in self.child_nodelists,
            nodelist = getattr(self, attr, None)
#ANNOTATION: get attr attribute of self object, if it exists substitute it for nodelist, if not nodelist is None.
            if nodelist:
#ANNOTATION: if nodelist is true,
                nodes.extend(nodelist.get_nodes_by_type(nodetype))
#ANNOTATION: call the method nodelist.get_nodes_by_type with an argument nodetype, extend nodes with the result.
        return nodes
#ANNOTATION: return nodes.


class NodeList(list):
#ANNOTATION: derive the class NodeList form the base class list.
    # Set to True the first time a non-TextNode is inserted by
    # extend_nodelist().
    contains_nontext = False
#ANNOTATION: contains_nontext is boolean False.

    def render(self, context):
#ANNOTATION: define the method render with 2 arguments: self and context.
        bits = []
#ANNOTATION: bits is an empty list.
        for node in self:
#ANNOTATION: for every node in self,
            if isinstance(node, Node):
#ANNOTATION: if node is an instance of Node,
                bit = self.render_node(node, context)
#ANNOTATION: call the method self.render_node with 2 arguments: node and context, substitute the result for bit.
            else:
#ANNOTATION: if not,
                bit = node
#ANNOTATION: substitute node for bit.
            bits.append(force_text(bit))
#ANNOTATION: call the function force_text with an argument bit, append the result to bits.
        return mark_safe(''.join(bits))
#ANNOTATION: call the function mark_safe with an argument, elements of bits joined into a string, return the result.

    def get_nodes_by_type(self, nodetype):
#ANNOTATION: define the method get_nodes_by_type with 2 arguments: self and nodetype.
        "Return a list of all nodes of the given type"
#ANNOTATION: docstring
        nodes = []
#ANNOTATION: modes is an empty list.
        for node in self:
#ANNOTATION: for every node in self,
            nodes.extend(node.get_nodes_by_type(nodetype))
#ANNOTATION: call the method node.get_nodes_by_type with an argument nodetype, extend nodes with it.
        return nodes
#ANNOTATION: return nodes.

    def render_node(self, node, context):
#ANNOTATION: define the method render_node with 3 arguments: self, node and context.
        return node.render(context)
#ANNOTATION: call the method node.render with an argument context, return the result. 


class TextNode(Node):
#ANNOTATION: derive the class TextNode form the base class Node.
    def __init__(self, s):
#ANNOTATION: define the method __init__ with 2 arguments: self and s.
        self.s = s
#ANNOTATION: substitute s for self.s.

    def __repr__(self):
#ANNOTATION: define the method __repr__ with an argument self.
        return force_str("<Text Node: '%s'>" % self.s[:25], 'ascii',
                errors='replace')
#ANNOTATION: call the function force_str with 3 arguments: string "<Text Node: '%s'>", with '%s' replaced with first 25 elements of self.s string,
#ANNOTATION: string 'ascii' and errors set to a string 'replace', return the result.

    def render(self, context):
#ANNOTATION: define the method render with 2 arguments: self and context.
        return self.s
#ANNOTATION: return self.s.


def render_value_in_context(value, context):
#ANNOTATION: define the function render_value_in_context with 2 arguments: value and context.
    """
    Converts any value to a string to become part of a rendered template. This
    means escaping, if required, and conversion to a unicode object. If value
    is a string, it is expected to have already been translated.
    """
#ANNOTATION: docstring
    value = template_localtime(value, use_tz=context.use_tz)
#ANNOTATION: call the method template_localtime with 2 arguments: value and use_tz=context.use_tz, substitute the result for value.
    value = localize(value, use_l10n=context.use_l10n)
#ANNOTATION: call the function localize with 2 arguments: value and use_l10n=context.use_l10n, substitute the result for value.
    value = force_text(value)
#ANNOTATION: call the function force_text with an argument value, substitute the result for value.
    if ((context.autoescape and not isinstance(value, SafeData)) or
            isinstance(value, EscapeData)):
#ANNOTATION: if context.autoescape is true and value is not an instance of SafeData, or value is an instance of EscapeData,
        return escape(value)
#ANNOTATION: call the function escape with an argument value, return the result.
    else:
#ANNOTATION: if not,
        return value
#ANNOTATION: return value.


class VariableNode(Node):
#ANNOTATION: derive the class VariableNode form the base class Node.
    def __init__(self, filter_expression):
#ANNOTATION: define the method __init__ with 2 arguments: self and filter_expression.
        self.filter_expression = filter_expression
#ANNOTATION: substitute filter_expression for self.filter_expression.

    def __repr__(self):
#ANNOTATION: define the method __repr__ with an argument self.
        return "<Variable Node: %s>" % self.filter_expression
#ANNOTATION: return a string "<Variable Node: %s>", substitute '%s' with self.filter_expression.

    def render(self, context):
#ANNOTATION: define the method render with 2 arguments self and context.
        try:
#ANNOTATION: try,
            output = self.filter_expression.resolve(context)
#ANNOTATION: call the method self.filter_expression.resolve with an argument context, substitute the result for output.
        except UnicodeDecodeError:
#ANNOTATION: if UnicodeDecodeError exception is caught,
            # Unicode conversion can fail sometimes for reasons out of our
            # control (e.g. exception rendering). In that case, we fail
            # quietly.
            return ''
#ANNOTATION: return an empty string.
        return render_value_in_context(output, context)
#ANNOTATION: call the function render_value_in_context with 2 arguments output and context, return the result.

# Regex for token keyword arguments
kwarg_re = re.compile(r"(?:(\w+)=)?(.+)")
#ANNOTATION: call the function re.compile with an argument raw string "(?:(\w+)=)?(.+)", substitute the result for kwarg_re.


def token_kwargs(bits, parser, support_legacy=False):
#ANNOTATION: define the method token_kwargs: bits, parser and support_legacy set to boolean False.
    """
    A utility method for parsing token keyword arguments.

    :param bits: A list containing remainder of the token (split by spaces)
        that is to be checked for arguments. Valid arguments will be removed
        from this list.

    :param support_legacy: If set to true ``True``, the legacy format
        ``1 as foo`` will be accepted. Otherwise, only the standard ``foo=1``
        format is allowed.

    :returns: A dictionary of the arguments retrieved from the ``bits`` token
        list.

    There is no requirement for all remaining token ``bits`` to be keyword
    arguments, so the dictionary will be returned as soon as an invalid
    argument format is reached.
    """
#ANNOTATION: docstring
    if not bits:
#ANNOTATION: if bits is false,
        return {}
#ANNOTATION: return an empty dictionary.
    match = kwarg_re.match(bits[0])
#ANNOTATION: call the method kwarg_re.match with an argument first element of bits, substitute the result for match.
    kwarg_format = match and match.group(1)
#ANNOTATION: if match is true and call to the method match.group with an argument integer 1 evaluates to true, kwarg_format is boolean True,
#ANNOTATION: otherwise it is boolean False.
    if not kwarg_format:
#ANNOTATION: if kwarg_format is false,
        if not support_legacy:
#ANNOTATION: if support_legacy is false,
            return {}
#ANNOTATION: return an empty dictionary.
        if len(bits) < 3 or bits[1] != 'as':
#ANNOTATION: if length of bits is lesser than integer 3 or second element of bits is not equal to string 'as',
            return {}
#ANNOTATION: return an empty dictionary.

    kwargs = {}
#ANNOTATION: kwargs is an empty dictionary,
    while bits:
#ANNOTATION: while bits is true,
        if kwarg_format:
#ANNOTATION: if kwarg_format is true,
            match = kwarg_re.match(bits[0])
#ANNOTATION: call the method kwarg_re.match with an argument first element of bits, substitute the result for match.
            if not match or not match.group(1):
#ANNOTATION: if match is false or call to the method match.group with an argument integer 1 evaluates to boolean false,
                return kwargs
#ANNOTATION: return kwargs.
            key, value = match.groups()
#ANNOTATION: call the method match.groups with 2 arguments: key and value.
            del bits[:1]
#ANNOTATION: delete first element of bits.
        else:
#ANNOTATION: if not,
            if len(bits) < 3 or bits[1] != 'as':
#ANNOTATION: if length of bits is lesser than integer 3 or second element of bits is not equal to string 'as',
                return kwargs
#ANNOTATION: return kwargs.
            key, value = bits[2], bits[0]
#ANNOTATION: substitute third and first element of bits for key and value, respectively.
            del bits[:3]
#ANNOTATION: delete first 3 elements of bits.
        kwargs[key] = parser.compile_filter(value)
#ANNOTATION: call the method parser.compile_filter with an argument value, substitute the result for value under the key key of kwargs dictionary.
        if bits and not kwarg_format:
#ANNOTATION: if bits is true and kwarg_format is false,
            if bits[0] != 'and':
#ANNOTATION: if first element of bits is not equal to string 'and',
                return kwargs
#ANNOTATION: return kwargs.
            del bits[:1]
#ANNOTATION: delete first element of bits.
    return kwargs
#ANNOTATION: return kwargs.


def parse_bits(parser, bits, params, varargs, varkw, defaults,
               takes_context, name):
#ANNOTATION: define the function parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and name.
    """
    Parses bits for template tag helpers (simple_tag, include_tag and
    assignment_tag), in particular by detecting syntax errors and by
    extracting positional and keyword arguments.
    """
#ANNOTATION: docstring
    if takes_context:
#ANNOTATION: if takes_context is true,
        if params[0] == 'context':
#ANNOTATION: if first element of params equals a string 'context',
            params = params[1:]
#ANNOTATION: substitute params without the first element for params.
        else:
#ANNOTATION: if not,
            raise TemplateSyntaxError(
                "'%s' is decorated with takes_context=True so it must "
                "have a first argument of 'context'" % name)
#ANNOTATION: raise an TemplateSyntaxError exception "'%s' is decorated with takes_context=True so it must have a first argument of 'context'",
#ANNOTATION: where '%s' is replaced with name.
    args = []
#ANNOTATION: args is an empty list.
    kwargs = {}
#ANNOTATION: kwargs is an empty dictionary.
    unhandled_params = list(params)
#ANNOTATION: convert params into a list, substitute it for unhandled_params.
    for bit in bits:
#ANNOTATION: for every bit in bits,
        # First we try to extract a potential kwarg from the bit
        kwarg = token_kwargs([bit], parser)
#ANNOTATION: call the function 
        if kwarg:
#ANNOTATION: if kwarg is true,
            # The kwarg was successfully extracted
            param, value = list(six.iteritems(kwarg))[0]
#ANNOTATION: call the method six.iteritems with an argument kwarg, convert the result into a list,  
#ANNOTATION: substitute first element of the result for param and value.
            if param not in params and varkw is None:
#ANNOTATION: if param is not in params and varkw is None,
                # An unexpected keyword argument was supplied
                raise TemplateSyntaxError(
                    "'%s' received unexpected keyword argument '%s'" %
                    (name, param))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument "'%s' received unexpected keyword argument '%s'",
#ANNOTATION: where '%s' are replaced with name and param.
            elif param in kwargs:
#ANNOTATION: otherwise if param is contained in kwargs,
                # The keyword argument has already been supplied once
                raise TemplateSyntaxError(
                    "'%s' received multiple values for keyword argument '%s'" %
                    (name, param))
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "'%s' received multiple values for keyword argument '%s'", 
#ANNOTATION: where '%s' are replaced with name and param.
            else:
#ANNOTATION: if not,
                # All good, record the keyword argument
                kwargs[str(param)] = value
#ANNOTATION: convert param to a string, use it as a key to get the value from kwargs dictionary, assign it value.
                if param in unhandled_params:
#ANNOTATION: if param is contained in unhandled_params,
                    # If using the keyword syntax for a positional arg, then
                    # consume it.
                    unhandled_params.remove(param)
#ANNOTATION: call the method unhandled_params.remove with an argument param.
        else:
#ANNOTATION: if not,
            if kwargs:
#ANNOTATION: if kwargs is true,
                raise TemplateSyntaxError(
                    "'%s' received some positional argument(s) after some "
                    "keyword argument(s)" % name)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "'%s' received some positional argument(s) after some keyword argument(s)", where '%s' is replaced with name.
            else:
#ANNOTATION: if not,
                # Record the positional argument
                args.append(parser.compile_filter(bit))
#ANNOTATION: call the method parser.compile_filter with an argument bit, append the result to args.
                try:
#ANNOTATION: try,
                    # Consume from the list of expected positional arguments
                    unhandled_params.pop(0)
#ANNOTATION: remove first element of unhandled_params.
                except IndexError:
#ANNOTATION: if IndexError exception is caught,
                    if varargs is None:
#ANNOTATION: if varargs is None,
                        raise TemplateSyntaxError(
                            "'%s' received too many positional arguments" %
                            name)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "'%s' received too many positional arguments", 
#ANNOTATION: where '%s' is replaced with name.
    if defaults is not None:
#ANNOTATION: if defaults is not None,
        # Consider the last n params handled, where n is the
        # number of defaults.
        unhandled_params = unhandled_params[:-len(defaults)]
#ANNOTATION: slice list unhandled_params from the beginning to the length of defaults last element,
    if unhandled_params:
#ANNOTATION: if unhandled_params is true,
        # Some positional arguments were not supplied
        raise TemplateSyntaxError(
            "'%s' did not receive value(s) for the argument(s): %s" %
            (name, ", ".join("'%s'" % p for p in unhandled_params)))
#ANNOTATION: raise TemplateSyntaxError(
            "'%s' did not receive value(s) for the argument(s): %s" %
            (name, ", ".join("'%s'" % p for p in unhandled_params)))
    return args, kwargs
#ANNOTATION: return args and kwargs.


def generic_tag_compiler(parser, token, params, varargs, varkw, defaults,
                         name, takes_context, node_class):
#ANNOTATION: define the method generic_tag_compiler with 9 arguments: parser, token, params, varargs, varkw, defaults, name, takes_context,
#ANNOTATION: and node_class.
    """
    Returns a template.Node subclass.
    """
#ANNOTATION: docstring
    bits = token.split_contents()[1:]
#ANNOTATION: call the function token.split_contents, substitute the result without the first element for bits.
    args, kwargs = parse_bits(parser, bits, params, varargs, varkw,
                              defaults, takes_context, name)
#ANNOTATION: call the method parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and name,
#ANNOTATION: substitute the result for args and kwargs, respectively.
    return node_class(takes_context, args, kwargs)
#ANNOTATION: call the function node_class with 3 arguments: takes_context, args and kwargs.


class TagHelperNode(Node):
#ANNOTATION: derive the class TagHelperNode form the base class Node.
    """
    Base class for tag helper nodes such as SimpleNode, InclusionNode and
    AssignmentNode. Manages the positional and keyword arguments to be passed
    to the decorated function.
    """
#ANNOTATION: docstring

    def __init__(self, takes_context, args, kwargs):
#ANNOTATION: define the method __init__ with 4 arguments: self, takes_context, args and kwargs.
        self.takes_context = takes_context
#ANNOTATION: substitute takes_context for self.takes_context.
        self.args = args
#ANNOTATION: substitute args for self.args.
        self.kwargs = kwargs
#ANNOTATION: substitute kwargs for self.kwargs.

    def get_resolved_arguments(self, context):
#ANNOTATION: define the method get_resolved_arguments with 2 arguments: self and context.
        resolved_args = [var.resolve(context) for var in self.args]
#ANNOTATION: resolved_args is an list with elements, return value of the method var.resolve with an argument context, for every var in self.args.
        if self.takes_context:
#ANNOTATION: if self.takes_context is true,
            resolved_args = [context] + resolved_args
#ANNOTATION: append resolved_args to a list containing context element, substitute it for resolved_args.
        resolved_kwargs = dict((k, v.resolve(context)) for k, v in self.kwargs.items())
#ANNOTATION: resolved_kwargs is dictionary with elements: return value of the method v.resolve called with an argument context, for k,
#ANNOTATION: for every k and v in return value of the method self.kwargs.items.
        return resolved_args, resolved_kwargs
#ANNOTATION: return resolved_args and resolved_kwargs.


class Library(object):
#ANNOTATION: derive the class Library form the base class object.
    def __init__(self):
#ANNOTATION: define the method with reload with an argument self.
        self.filters = {}
#ANNOTATION: self.filters is an empty dictionary.
        self.tags = {}
#ANNOTATION: self.tags is an empty dictionary.

    def tag(self, name=None, compile_function=None):
#ANNOTATION: define the method tag with 3 arguments: self, name set to None and compile_function set to None.
        if name is None and compile_function is None:
#ANNOTATION: if name is None and compile_function is None,
            # @register.tag()
            return self.tag_function
#ANNOTATION: return self.tag_function.
        elif name is not None and compile_function is None:
#ANNOTATION: otherwise if name is not None and compile_function is None,
            if callable(name):
#ANNOTATION: if name is callable object,
                # @register.tag
                return self.tag_function(name)
#ANNOTATION: call the method self.tag_function with an argument name, return the result.
            else:
#ANNOTATION: if not,
                # @register.tag('somename') or @register.tag(name='somename')
                def dec(func):
#ANNOTATION: define the function dec with an argument func,
                    return self.tag(name, func)
#ANNOTATION: call the method self.tag with 2 arguments name and func, return the result.
                return dec
#ANNOTATION: return dec.
        elif name is not None and compile_function is not None:
#ANNOTATION: otherwise if name is not None and compile_function is not None,
            # register.tag('somename', somefunc)
            self.tags[name] = compile_function
#ANNOTATION: substitute compile_function for self.tags dictionary value under the name key.
            return compile_function
#ANNOTATION: return compile_function.
        else:
#ANNOTATION: if not,
            raise InvalidTemplateLibrary("Unsupported arguments to "
                "Library.tag: (%r, %r)", (name, compile_function))
#ANNOTATION: raise an InvalidTemplateLibrary exception with an argument string "Unsupported arguments to Library.tag: (%r, %r)", 
#ANNOTATION: substitute '%r' with name and compile_function.

    def tag_function(self, func):
#ANNOTATION: define the method tag_function with 2 argument: self and func.
        self.tags[getattr(func, "_decorated_function", func).__name__] = func
#ANNOTATION: get "_decorated_function" attribute from func, return func if the attribute doesnt exists, 
#ANNOTATION: use its __name__ field as a key to get the value from self.tags, assign func to it. 
        return func
#ANNOTATION: return func.

    def filter(self, name=None, filter_func=None, **flags):
#ANNOTATION: define the method filter with 4 arguments: self, name set to None, filter_func set to None and unpacked dictionary flags.
        if name is None and filter_func is None:
#ANNOTATION: if name is None and filter_func is None,
            # @register.filter()
            def dec(func):
#ANNOTATION: define the function dec with an argument func,
                return self.filter_function(func, **flags)
#ANNOTATION: call the method self.filter_function with 2 arguments func and unpacked dictionary flags, return the result.
            return dec
#ANNOTATION: return dec.

        elif name is not None and filter_func is None:
#ANNOTATION: otherwise if name is not None and filter_func is None,
            if callable(name):
#ANNOTATION: if name is callable object,
                # @register.filter
                return self.filter_function(name, **flags)
#ANNOTATION: call the method self.filter_function with arguments name and unpacked dictionary flags, return the result.
            else:
#ANNOTATION: if not,
                # @register.filter('somename') or @register.filter(name='somename')
                def dec(func):
#ANNOTATION: define the function dec with an argument func,
                    return self.filter(name, func, **flags)
#ANNOTATION: call the method self.filter with 3 arguments: name, func and unpacked dictionary flags, return the result.
                return dec
#ANNOTATION: return dec.

        elif name is not None and filter_func is not None:
#ANNOTATION: otherwise if name is not None and filter_func is not None,
            # register.filter('somename', somefunc)
            self.filters[name] = filter_func
#ANNOTATION: substitute filter_func for value under the name key of self.filters dictionary.
            for attr in ('expects_localtime', 'is_safe', 'needs_autoescape'):
#ANNOTATION: for every attr in tuple with 3 arguments: strings 'expects_localtime', 'is_safe' and 'needs_autoescape',
                if attr in flags:
#ANNOTATION: if attr is contained in flags,
                    value = flags[attr]
#ANNOTATION: substitute value under the attr key of flags dictionary for value.
                    # set the flag on the filter for FilterExpression.resolve
                    setattr(filter_func, attr, value)
#ANNOTATION: set filter_func objec attr attribute to value.
                    # set the flag on the innermost decorated function
                    # for decorators that need it e.g. stringfilter
                    if hasattr(filter_func, "_decorated_function"):
#ANNOTATION: if filter_func has an attribute "_decorated_function",
                        setattr(filter_func._decorated_function, attr, value)
#ANNOTATION: set filter_func._decorated_function objects attr attribute to value.
            filter_func._filter_name = name
#ANNOTATION: substitute name for filter_func._filter_name.
            return filter_func
#ANNOTATION: return filter_func.
        else:
#ANNOTATION: if not,
            raise InvalidTemplateLibrary("Unsupported arguments to "
                "Library.filter: (%r, %r)", (name, filter_func))
#ANNOTATION: raise an InvalidTemplateLibrary exception with an argument string ("Unsupported arguments to Library.filter: (%r, %r)",
#ANNOTATION: where '%r' is replaced with name and filter_func, respectively.

    def filter_function(self, func, **flags):
#ANNOTATION: define the method filter_function with 3 arguments: self, func and unpacked dictionary flags.
        name = getattr(func, "_decorated_function", func).__name__
#ANNOTATION: get "_decorated_function" attribute from func object, if it exists substitute __name__ field of the result for name,
#ANNOTATION: if not, substitute func.__name__ for name.
        return self.filter(name, func, **flags)
#ANNOTATION: call the method self.filter with 3 arguments: name, func and unpacked dictionary flags.

    def simple_tag(self, func=None, takes_context=None, name=None):
#ANNOTATION: define the method simple_tag with 4 arguments: self, func and None, takes_context and None and name set to None.
        def dec(func):
#ANNOTATION: define the function dec with an argument func.
            params, varargs, varkw, defaults = getargspec(func)
#ANNOTATION: call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults, respectively.

            class SimpleNode(TagHelperNode):
#ANNOTATION: derive the class SimpleNode form the base class TagHelperNode.

                def render(self, context):
#ANNOTATION: define the method render with 2 arguments self and context.
                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)
#ANNOTATION: call the method self.get_resolved_arguments with an argument context, substitute the result for resolved_args and resolved_kwargs.
                    return func(*resolved_args, **resolved_kwargs)
#ANNOTATION: call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs, return it.

            function_name = (name or
                getattr(func, '_decorated_function', func).__name__)
#ANNOTATION: if name is true, substitute it for function_name, if not get attribute '_decorated_function' from func object,
#ANNOTATION: substitute its __name__ field for function name, if it doesnt exists substitute func.__name__ for function_name.
            compile_func = partial(generic_tag_compiler,
                params=params, varargs=varargs, varkw=varkw,
                defaults=defaults, name=function_name,
                takes_context=takes_context, node_class=SimpleNode)
#ANNOTATION: call the function generic_tag_compiler, params set to params, varargs set to varargs, varkw set to varkw, defaults set to defaults, 
#ANNOTATION: name set to function_name, and takes_context set to takes_context and node_class set to SimpleNode.
            compile_func.__doc__ = func.__doc__
#ANNOTATION: substitute func.__doc__ for compile_func.__doc__.
            self.tag(function_name, compile_func)
#ANNOTATION: call the method self.tag with 2 arguments: function_name and compile_func.
            return func
#ANNOTATION: return func.

        if func is None:
#ANNOTATION: if func is None,
            # @register.simple_tag(...)
            return dec
#ANNOTATION: return dec.
        elif callable(func):
#ANNOTATION: otherwise if func is callable object,
            # @register.simple_tag
            return dec(func)
#ANNOTATION: call the function dec with an argument func, return the result.
        else:
#ANNOTATION: if not,
            raise TemplateSyntaxError("Invalid arguments provided to simple_tag")
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Invalid arguments provided to simple_tag".

    def assignment_tag(self, func=None, takes_context=None, name=None):
#ANNOTATION: define the method assignment_tag with 4 arguments: self, func set to None, takes_context set to None and name set to None.
        def dec(func):
#ANNOTATION: define the function dec with an argument func.
            params, varargs, varkw, defaults = getargspec(func)
#ANNOTATION: call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults.

            class AssignmentNode(TagHelperNode):
#ANNOTATION: derive the class AssignmentNode form the base class TagHelperNode.
                def __init__(self, takes_context, args, kwargs, target_var):
#ANNOTATION: define the function __init__ with 5 arguments: self, takes_context, args, kwargs and target_var.
                    super(AssignmentNode, self).__init__(takes_context, args, kwargs)
#ANNOTATION: call the method __init__ from the base class of the class AssignmentNode, with 3 arguments: takes_context, args and kwargs.
                    self.target_var = target_var
#ANNOTATION: substitute target_var for self.target_var.

                def render(self, context):
#ANNOTATION: define the method render with 2 arguments self and context.
                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)
#ANNOTATION: call the method self.get_resolved_arguments with an argument context, substitute the result for resolved_args and resolved_kwargs.
                    context[self.target_var] = func(*resolved_args, **resolved_kwargs)
#ANNOTATION: call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs,
#ANNOTATION: substitute the result for value under the self.target_var key of the context dictionary.
                    return ''
#ANNOTATION: return an empty string.

            function_name = (name or
                getattr(func, '_decorated_function', func).__name__)
#ANNOTATION: if name is true, substitute it for function_name, if not get '_decorated_function' attribute from func object, if it exists,
#ANNOTATION: substitute __name__ field of the result for function_name, in not, substitute func.__name__ for function_name.

            def compile_func(parser, token):
#ANNOTATION: define the function compile_func with 2 arguments: parser and token. 
                bits = token.split_contents()[1:]
#ANNOTATION: call the function token.split_contents, substitute the result without the first element for bits.
                if len(bits) < 2 or bits[-2] != 'as':
#ANNOTATION: if length of bits is smaller than integer 2 or second last element of bits is not equal to 'as',
                    raise TemplateSyntaxError(
                        "'%s' tag takes at least 2 arguments and the "
                        "second last argument must be 'as'" % function_name)
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string, "'%s' tag takes at least 2 arguments and the second last argument
#ANNOTATION: must be 'as'", where '%s' is replaced with function_name.
                target_var = bits[-1]
#ANNOTATION: substitute last element of bits for target_var.
                bits = bits[:-2]
#ANNOTATION: substitute bits without last two elements for bits.
                args, kwargs = parse_bits(parser, bits, params,
                    varargs, varkw, defaults, takes_context, function_name)
#ANNOTATION: call the function parse_bits with 8 arguments: parser, bits, params, varargs, varkw, defaults, takes_context and function_name,
#ANNOTATION: substitute the result for args and kwargs.
                return AssignmentNode(takes_context, args, kwargs, target_var)
#ANNOTATION: return an instance of AssignmentNode class created with 4 arguments: takes_context, args, kwargs and target_var.

            compile_func.__doc__ = func.__doc__
#ANNOTATION: substitute func.__doc__ for compile_func.__doc__.
            self.tag(function_name, compile_func)
#ANNOTATION: call the method self.tag with 2 arguments: function_name and compile_func.
            return func
#ANNOTATION: return func.

        if func is None:
#ANNOTATION: if func is None,
            # @register.assignment_tag(...)
            return dec
#ANNOTATION: return dec.
        elif callable(func):
#ANNOTATION: otherwise if func is callable,
            # @register.assignment_tag
            return dec(func)
#ANNOTATION: call the function dec with an argument func, return the result.
        else:
#ANNOTATION: if not,
            raise TemplateSyntaxError("Invalid arguments provided to assignment_tag")
#ANNOTATION: raise an TemplateSyntaxError exception with an argument string "Invalid arguments provided to assignment_tag".

    def inclusion_tag(self, file_name, context_class=Context, takes_context=False, name=None):
#ANNOTATION: define the method inclusion_tag with 5 arguments: self, file_name, context_class set to Context, takes_context set to boolean False,
#ANNOTATION: and name set to None.
        def dec(func):
#ANNOTATION: define the function dec with an argument func.
            params, varargs, varkw, defaults = getargspec(func)
#ANNOTATION: call the function getargspec with an argument func, substitute the result for params, varargs, varkw and defaults.

            class InclusionNode(TagHelperNode):
#ANNOTATION: derive the class InclusionNode form the base class TagHelperNode.

                def render(self, context):
#ANNOTATION: define the method render with 2 arguments: self and context. 
                    resolved_args, resolved_kwargs = self.get_resolved_arguments(context)
#ANNOTATION: call the method self.get_resolved_arguments with context as an argument, substitute the result for resolved_args and resolved_kwargs. 
                    _dict = func(*resolved_args, **resolved_kwargs)
#ANNOTATION: call the function func with 2 arguments: unpacked list resolved_args and unpacked dictionary resolved_kwargs, substitute the result for _dict.

                    if not getattr(self, 'nodelist', False):
#ANNOTATION: get 'nodelist' attribute from self object. if it doesnt exists return boolean False, if the result evaluates to false, 
                        from django.template.loader import get_template, select_template
#ANNOTATION: from django.template.loader import get_template, select_template.
                        if isinstance(file_name, Template):
#ANNOTATION: if file_name is an instance of Template class.
                            t = file_name
#ANNOTATION: substitute file_name for t.
                        elif not isinstance(file_name, six.string_types) and is_iterable(file_name):
#ANNOTATION: otherwise if file_name is not an instance of six.string_types and call to the function is_iterable with an argument file_name,
#ANNOTATION: evaluates to true,
                            t = select_template(file_name)
#ANNOTATION: call the function select_template with an argument file_name, substitute the result for t.
                        else:
#ANNOTATION: if not,
                            t = get_template(file_name)
#ANNOTATION: call the function get_template with an argument file_name, substitute the result for t.
                        self.nodelist = t.nodelist
#ANNOTATION: substitute t.nodelist for self.nodelist.
                    new_context = context_class(_dict, **{
                        'autoescape': context.autoescape,
                        'current_app': context.current_app,
                        'use_l10n': context.use_l10n,
                        'use_tz': context.use_tz,
                    })
#ANNOTATION: call the function context_class with 2 arguments: _dict and unpacked dictionary containing 4 entries:
#ANNOTATION: context.autoescape for 'autoescape', context.autoescape for 'current_app', context.use_l10n for 'use_l10n',
#ANNOTATION: and context.use_tz for 'use_tz', substitute the result for new_context.
                    # Copy across the CSRF token, if present, because
                    # inclusion tags are often used for forms, and we need
                    # instructions for using CSRF protection to be as simple
                    # as possible.
                    csrf_token = context.get('csrf_token', None)
#ANNOTATION: call the function context.get with 2 argument 'csrf_token' and None, substitute the result for csrf_token.
                    if csrf_token is not None:
#ANNOTATION: if csrf_token is not None,
                        new_context['csrf_token'] = csrf_token
#ANNOTATION: substitute csrf_token for value under the 'csrf_token' key of new_context dictionary.
                    return self.nodelist.render(new_context)
#ANNOTATION: call the method self.nodelist.render with an argument new_context, return the result.

            function_name = (name or
                getattr(func, '_decorated_function', func).__name__)
#ANNOTATION: if name is true, substitute it for function_name, if not get '_decorated_function' attribute from func object, if it exists,
#ANNOTATION: substitute __name__ field of the result for function_name, in not, substitute func.__name__ for function_name.
            compile_func = partial(generic_tag_compiler,
                params=params, varargs=varargs, varkw=varkw,
                defaults=defaults, name=function_name,
                takes_context=takes_context, node_class=InclusionNode)
#ANNOTATION: call the function partial with 8 arguments: generic_tag_compiler, params set to params, varargs set to varargs, varkw set to varkw,
#ANNOTATION: defaults set to defaults, name set to function_name, takes_context set to takes_context and node_class set to InclusionNode,
#ANNOTATION: substitute the result for compile_func.
            compile_func.__doc__ = func.__doc__
#ANNOTATION: substitute func.__doc__ for compile_func.__doc__.
            self.tag(function_name, compile_func)
#ANNOTATION: call the function self.tag with 2 arguments: function_name and compile_func.
            return func
#ANNOTATION: return func.
        return dec
#ANNOTATION: return dec.


def is_library_missing(name):
#ANNOTATION: define the function is_library_missing with an argument name.
    """Check if library that failed to load cannot be found under any
    templatetags directory or does exist but fails to import.

    Non-existing condition is checked recursively for each subpackage in cases
    like <appdir>/templatetags/subpackage/package/module.py.
    """
#ANNOTATION: docstring
    # Don't bother to check if '.' is in name since any name will be prefixed
    # with some template root.
    path, module = name.rsplit('.', 1)
#ANNOTATION: split string name into two parts from the right side by the separator '.', substitute parts for path and module, respectively.
    try:
#ANNOTATION: try,
        package = import_module(path)
#ANNOTATION: call the function import_module with an argument path, substitute it for package.
        return not module_has_submodule(package, module)
#ANNOTATION: call the function module_has_submodule with 2 arguments: package and module, return inverted boolean result.
    except ImportError:
#ANNOTATION: if ImportError exception is caught,
        return is_library_missing(path)
#ANNOTATION: call the function is_library_missing with an argument path, return the result.


def import_library(taglib_module):
#ANNOTATION: define the function import_library with an argument taglib_module.
    """
    Load a template tag library module.

    Verifies that the library contains a 'register' attribute, and
    returns that attribute as the representation of the library
    """
#ANNOTATION: docstring
    try:
#ANNOTATION: try,
        mod = import_module(taglib_module)
#ANNOTATION: call the function import_module with an argument taglib_module, substitute the result for mod.
    except ImportError as e:
#ANNOTATION: if ImportError, renamed to e, exception is caught,
        # If the ImportError is because the taglib submodule does not exist,
        # that's not an error that should be raised. If the submodule exists
        # and raised an ImportError on the attempt to load it, that we want
        # to raise.
        if is_library_missing(taglib_module):
#ANNOTATION: call the function is_library_missing with an argument taglib_module, if it evaluates to true,
            return None
#ANNOTATION: return None.
        else:
#ANNOTATION: if not,
            raise InvalidTemplateLibrary("ImportError raised loading %s: %s" %
                                         (taglib_module, e))
#ANNOTATION: raise an InvalidTemplateLibrary exception with an argument string "ImportError raised loading %s: %s", 
#ANNOTATION: where '%s' is replaced with taglib_module and e.
    try:
#ANNOTATION: try,
        return mod.register
#ANNOTATION: return mod.register.
    except AttributeError:
#ANNOTATION: if AttributeError exception is caught,
        raise InvalidTemplateLibrary("Template library %s does not have "
                                     "a variable named 'register'" %
                                     taglib_module)
#ANNOTATION: raise an InvalidTemplateLibrary exception with an argument string "Template library %s does not have a variable named 'register'",
#ANNOTATION: where '%s' is replaced with taglib_module.

templatetags_modules = []
#ANNOTATION: templatetags_modules is an empty list.


def get_templatetags_modules():
#ANNOTATION: define the function get_templatetags_modules.
    """
    Return the list of all available template tag modules.

    Caches the result for faster access.
    """
#ANNOTATION: docstring
    global templatetags_modules
#ANNOTATION: use global variable templatetags_modules.
    if not templatetags_modules:
#ANNOTATION: if templatetags_modules is false,
        _templatetags_modules = []
#ANNOTATION: _templatetags_modules is an empty list.
        # Populate list once per process. Mutate the local list first, and
        # then assign it to the global name to ensure there are no cases where
        # two threads try to populate it simultaneously.

        templatetags_modules_candidates = ['django.templatetags']
#ANNOTATION: templatetags_modules_candidates is an list with an argument string 'django.templatetags'.
        templatetags_modules_candidates += ['%s.templatetags' % app_config.name
            for app_config in apps.get_app_configs()]
#ANNOTATION: add string '%s.templatetags' to a list, where '%s' is replaced with app_config.name, 
#ANNOTATION: for every app_config in result of the method apps.get_app_configs, append the resulting list to templatetags_modules_candidates.
        for templatetag_module in templatetags_modules_candidates:
#ANNOTATION: for every templatetag_module in templatetags_modules_candidates,
            try:
#ANNOTATION: try,
                import_module(templatetag_module)
#ANNOTATION: call the function import_module with an argument templatetag_module.
                _templatetags_modules.append(templatetag_module)
#ANNOTATION: append templatetag_module to _templatetags_modules.
            except ImportError:
#ANNOTATION: if ImportError exception is caught,
                continue
#ANNOTATION: skip this loop iteration.
        templatetags_modules = _templatetags_modules
#ANNOTATION: substitute _templatetags_modules for templatetags_modules.
    return templatetags_modules
#ANNOTATION: return templatetags_modules.


def get_library(library_name):
#ANNOTATION: define the function get_library with an argument library_name.
    """
    Load the template library module with the given name.

    If library is not already loaded loop over all templatetags modules
    to locate it.

    {% load somelib %} and {% load someotherlib %} loops twice.

    Subsequent loads eg. {% load somelib %} in the same process will grab
    the cached module from libraries.
    """
#ANNOTATION: docstring
    lib = libraries.get(library_name, None)
#ANNOTATION: get the value under the library_name key of the libraries dictionary, if it exists, substitute it for lib, if not, lib is None. 
    if not lib:
#ANNOTATION: if lib is false,
        templatetags_modules = get_templatetags_modules()
#ANNOTATION: call the function get_templatetags_modules, substitute the result for templatetags_modules.
        tried_modules = []
#ANNOTATION: tried_modules is an empty list.
        for module in templatetags_modules:
#ANNOTATION: for every module in templatetags_modules,
            taglib_module = '%s.%s' % (module, library_name)
#ANNOTATION: taglib_module is an string '%s.%s', where '%s' is replaced to module and library_name.
            tried_modules.append(taglib_module)
#ANNOTATION: append taglib_module to tried_modules.
            lib = import_library(taglib_module)
#ANNOTATION: call the function import_library with an argument taglib_module, substitute the result for lib.
            if lib:
#ANNOTATION: if lib is true,
                libraries[library_name] = lib
#ANNOTATION: substitute lib for value under the library_name key of libraries dictionary.
                break
#ANNOTATION: break loop execution.
        if not lib:
#ANNOTATION: if lib is false,
            raise InvalidTemplateLibrary("Template library %s not found, "
                                         "tried %s" %
                                         (library_name,
                                          ','.join(tried_modules)))
#ANNOTATION: raise an InvalidTemplateLibrary exception with an argument string "Template library %s not found, tried %s", 
#ANNOTATION: where '%s' is replaced with library_name and elements of tried_modules joined into a string, separated by ','.
    return lib
#ANNOTATION: return lib.


def add_to_builtins(module):
#ANNOTATION: define the function add_to_builtins with an argument module.
    builtins.append(import_library(module))
#ANNOTATION: call the function import_library with an argument module, append the result to builtins.


add_to_builtins('django.template.defaulttags')
#ANNOTATION: call the function add_to_builtins with an argument string 'django.template.defaulttags'.
add_to_builtins('django.template.defaultfilters')
#ANNOTATION: call the function add_to_builtins with an argument string 'django.template.defaultfilters'.
add_to_builtins('django.template.loader_tags')
#ANNOTATION: call the function add_to_builtins with an argument string 'django.template.loader_tags'.
